(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>🚀 Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## 💼 Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### 🌟 Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## 📂 Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
├── app/                       # Core application directory
│   ├── main.py                # FastAPI application entry point
│   ├── api/                   # API endpoints
│   │   ├── routes.py          # API route definitions
│   │   └── schemas.py         # Pydantic models for requests/responses
│   ├── services/              # Business logic services
│   │   ├── market_data.py     # Service for fetching market data
│   │   ├── trading.py         # Service for executing trades
│   │   └── backtesting.py     # Service for backtesting strategies
│   ├── strategies/            # Trading strategies
│   │   ├── base.py            # Base strategy class
│   │   ├── moving_average.py  # Moving Average Crossover strategy
│   │   ├── lstm_predictor.py  # LSTM-based prediction strategy
│   │   ├── transformer.py     # Transformer-based strategy
│   │   ├── llm_strategy.py    # LLM-powered strategy
│   │   └── msi_strategy.py    # Market Sentiment Index strategy
│   ├── db/                    # Database modules
│   │   ├── database.py        # Database connection
│   │   └── models.py          # SQLAlchemy models
│   ├── tasks/                 # Celery tasks
│   │   ├── celery_app.py      # Celery configuration
│   │   ├── training.py        # Tasks for model training
│   │   ├── trading.py         # Tasks for automated trading
│   │   └── data.py            # Tasks for data collection
│   └── utils/                 # Utility functions
├── docs/                      # Documentation directory
│   ├── for-dummies/           # Comprehensive guide for beginners
│   ├── guides/                # Specialized guides
│   │   ├── beginner/          # Beginner guides
│   │   └── advanced/          # Advanced guides
│   ├── api/                   # API documentation
│   ├── reference/             # Technical reference
│   └── README.md              # Documentation index
├── models/                    # Saved ML models
│   ├── lstm/                  # LSTM models and scalers
│   └── transformer/           # Transformer models and scalers
├── data/                      # Data directory
│   └── sample_data/           # Sample data for testing
├── reports/                   # Reports and visualizations
│   ├── comprehensive/         # Comprehensive simulation results
│   └── visualizations/        # Generated charts and graphs
├── tests/                     # Tests directory
├── comprehensive_simulation.py # Full-featured simulation script
├── strategy_dashboard.py      # Streamlit dashboard for strategy visualization
├── docker-compose.yml         # Docker Compose configuration
├── Dockerfile                 # Docker configuration
├── requirements.txt           # Python dependencies
├── .env.example              # Example environment variables
└── README.md                 # This file (you are here)
```
</details>

## 🚀 Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      • Python 3.11 or later<br>
      • Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      • Docker and Docker Compose (for containerized deployment)<br>
      • Polygon.io API key (for production-quality market data)<br>
      • Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      • Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### 💻 Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## 🏃‍♂️ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## 🔌 API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## 🔧 Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## 🔬 Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## 📚 Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### 📔 Guides Principaux

- **[🔍 Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrée central avec tous les guides disponibles
- **[📈 Guide de Day Trading](./docs/day_trading_guide.md)**: Système automatisé de day trading sur actions et crypto
- **[📊 Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[🧠 Guide d'Entraînement des Modèles](./docs/model_training_guide.md)**: Créer et entraîner des modèles d'IA

### 📖 Documentation Générale

- **[📚 Pour les Débutants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour débutants
- **[🔰 Guides Débutants](./docs/guides/beginner/)**: Ressources pour démarrer rapidement
- **[🔧 Guides Avancés](./docs/guides/advanced/)**: Sujets spécialisés pour traders expérimentés
- **[📝 Documentation Référence](./docs/reference/)**: Détails techniques et spécifications API

## 🧪 Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## 🤝 Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## 📄 License

This project is open-source and available under the MIT License.

## 🌟 Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## 🙏 Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: all_crypto_symbols.txt
================================================
ETHUSD
BATUSD
BTCUSD
DOTUSD
GRTUSD
DOGEUSD
PEPEUSD
BCHUSD
XTZUSD
LINKUSD
AVAXUSD
XRPUSD
SUSHIUSD
USDCUSD
CRVUSD
SHIBUSD
UNIUSD
USDTUSD
AAVEUSD
MKRUSD
TRUMPUSD
LTCUSD
SOLUSD
YFIUSD


================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisé pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durée de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    Système de daytrading crypto utilisant directement l'API Alpaca
    
    Caractéristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - Stratégie simple de croisement de moyennes mobiles
    - Plusieurs durées de session (1h, 4h, 8h, nuit)
    - Paramètres de trading configurables
    - Journalisation complète et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le système de trading crypto"""
        self.session_duration = session_duration
        
        # Déterminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("Configuré pour le trading LIVE (réel)")
        else:  # mode paper par défaut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("Configuré pour le trading PAPER (simulation)")
            
        # URL des données de marché
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # Paramètres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisée de symboles à utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrée
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'état
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisé")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # Vérifier que le client est correctement initialisé
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connecté: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # Vérifier la disponibilité du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"Trouvé {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisée et vérifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisée de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisé n'est tradable")
                    
                # Vérifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de récupérer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de récupérer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """Démarrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"Démarrage de la session de trading crypto à {self.session_start_time}")
        logger.info(f"La session se terminera à {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Échec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # Démarrer la boucle de trading
        self.trading_loop()
        
        # Générer un rapport de performance à la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # Déterminer les symboles à trader pour cette itération
                # Limiter aux 10 premières cryptos pour éviter les limites de taux si pas de liste personnalisée
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Afficher le solde disponible à chaque itération
                try:
                    account_info = self.api.get_account()
                    buying_power = float(account_info.buying_power)
                    cash = float(account_info.cash)
                    equity = float(account_info.equity)
                    
                    logger.info("\n===== INFORMATION DU COMPTE ALPACA =====")
                    logger.info(f"Solde disponible: ${buying_power:.2f}")
                    logger.info(f"Liquidités: ${cash:.2f}")
                    logger.info(f"Valeur totale: ${equity:.2f}")
                    logger.info("=======================================\n")
                except Exception as e:
                    logger.error(f"Erreur lors de la récupération du solde Alpaca: {e}")
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre à jour l'état du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itération
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminée")
    
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les données historiques (intervalles de 5 minutes pour les dernières 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaîne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de données historiques disponibles pour {symbol}")
                return
            
            # Si les données sont multi-index (symbole, timestamp), prendre juste le symbole concerné
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la dernière barre des dernières 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (dernière barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de données disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # Vérifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # Vérifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # Exécuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # Vérifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """Exécuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Arrondir la quantité à 6 décimales
            qty = round(qty, 6)
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """Exécuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"Quantité de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre à jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre à jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de récupération des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise à jour de l'état du portefeuille: {e}")
    
    def generate_performance_report(self):
        """Générer un rapport de performance à la fin de la session de trading"""
        # Créer un fichier de rapport séparé
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"Durée de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de début: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'état final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes à la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes à la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÉE")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de génération du rapport de performance: {e}")

        # Écrire le rapport également dans un fichier séparé
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"Durée de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de début: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de récupérer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes à la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de récupérer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÉSUMÉ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuée\n")
                
        logger.info(f"Rapport détaillé sauvegardé dans {report_file}")

def main():
    """Point d'entrée principal"""
    parser = argparse.ArgumentParser(description="Système de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="Durée de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="Durée personnalisée en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # Définir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # Déterminer la durée de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # Créer le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reçu, arrêt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Exécuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reçue, arrêt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exécution du trader crypto: {e}")
    finally:
        logger.info("Arrêt du trader crypto terminé")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

Vérifie spécifiquement les fonctionnalités premium de votre abonnement Alpaca à 100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api importé avec succès")
except ImportError:
    logger.error("❌ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api installé et importé avec succès")

def test_premium_features():
    """Teste les fonctionnalités spécifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester à la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # Récupérer les informations d'authentification appropriées
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"✅ Connecté à l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"✅ Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de déterminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"✅ Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("ℹ️ Impossible de déterminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des informations du compte: {e}")
            
            # 2. Test des données de marché historiques (journalières)
            logger.info("\n----- TEST DES DONNÉES DE MARCHÉ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test données journalières sur 5 jours (devrait fonctionner même sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données journalières pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"✅ {len(daily_bars)} barres journalières récupérées")
                    logger.info(f"   Dernier prix de clôture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"⚠️ Aucune donnée journalière récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données journalières: {e}")
            
            # 2.2 Test données minutes (souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données minutes pour {symbol} des dernières 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"✅ {len(minute_bars)} barres minutes récupérées")
                    logger.info(f"   Première barre: {minute_bars[0].t}")
                    logger.info(f"   Dernière barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"⚠️ Aucune donnée minute récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données minutes: {e}")
            
            # 2.3 Test historique étendu (2+ ans, souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération de l'historique étendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"✅ {len(long_bars)} barres d'historique étendu récupérées")
                        logger.info(f"   Couvrant {days_of_data} jours de données")
                    else:
                        logger.warning(f"⚠️ Historique limité à {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"⚠️ Aucune donnée d'historique étendu récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération de l'historique étendu: {e}")
            
            # 2.4 Test données pour plusieurs symboles simultanément
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"✅ Données récupérées pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("⚠️ Aucune donnée récupérée pour les multiples symboles")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données multi-symboles: {e}")
            
            # 3. Test des données de news (souvent limité aux abonnements premium)
            logger.info("\n----- TEST DES DONNÉES DE NEWS -----")
            try:
                logger.info(f"Récupération des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"✅ {len(news)} articles de news récupérés")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"⚠️ Aucune news récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des news: {e}")
            
            # Résumé des tests
            logger.info("\n----- RÉSUMÉ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"✅ Connexion au mode {mode.upper()}: Réussie")
            else:
                logger.error(f"❌ Connexion au mode {mode.upper()}: Échec")
                
            if results[mode]["account_info"]:
                logger.info(f"✅ Informations du compte: Disponibles")
            else:
                logger.error(f"❌ Informations du compte: Non disponibles")
            
            logger.info(f"Données de marché:")
            for data_type, success in results[mode]["market_data"].items():
                status = "✅ Disponible" if success else "❌ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "✅ Disponible" if results[mode]["news_data"] else "❌ Non disponible"
            logger.info(f"Données de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("🌟 Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("⭐ Votre compte semble avoir certaines fonctionnalités premium.")
            else:
                logger.warning("⚠️ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"❌ Erreur générale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\n🚀 DÉMARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vérifier si votre abonnement Alpaca à 100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\n🏁 TEST TERMINÉ")
    logger.info("Récapitulatif des fonctionnalités premium détectées:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "🌟 PREMIUM"
        elif premium_count >= 1:
            status = "⭐ PARTIEL"
        else:
            status = "❌ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalités premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalités premium, vérifiez que:")
    logger.info("1. Votre abonnement est bien activé sur le compte Alpaca")
    logger.info("2. Les clés API utilisées correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalités testées")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"✅ Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("❌ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"✅ Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("❌ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"❌ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"✅ Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("❌ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"❌ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"✅ Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"❌ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("✅ All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("❌ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vérification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalités spécifiques à l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vérifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("Clés API Alpaca non définies dans le fichier .env")
        return
        
    logger.info(f"Connexion à Alpaca avec la clé: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. Vérifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de récupérer les détails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de récupérer la configuration du compte: {e}")
        
        # 2. Vérifier l'accès aux données de marché
        # Symboles à tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÉES EN TEMPS RÉEL ====")
        
        # 2.1 Vérifier les données en temps réel
        try:
            logger.info(f"Récupération du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # Vérifier si l'horodatage est récent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"Délai des données: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("✅ DONNÉES EN TEMPS RÉEL CONFIRMÉES")
            else:
                logger.warning("⚠️ Les données semblent être retardées")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÉES HISTORIQUES PREMIUM ====")
        
        # 2.2 Vérifier l'accès aux données historiques étendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"✅ {len(bars)} jours de données historiques récupérées")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la période couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"Période couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("✅ HISTORIQUE ÉTENDU PREMIUM CONFIRMÉ")
                else:
                    logger.warning("⚠️ Historique limité, peut-être pas d'accès premium complet")
            else:
                logger.warning("Aucune donnée historique récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données historiques: {e}")
        
        # 2.3 Vérifier l'accès aux données à haute résolution
        logger.info("\n==== TEST DES DONNÉES À HAUTE RÉSOLUTION ====")
        try:
            # Test des données minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"✅ {len(minute_bars)} barres de données minutes récupérées")
                logger.info("✅ DONNÉES À HAUTE RÉSOLUTION CONFIRMÉES")
            else:
                logger.warning("Aucune donnée minute récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données minutes: {e}")
        
        # 2.4 Vérifier l'accès aux données de plusieurs symboles
        logger.info("\n==== TEST DES DONNÉES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"✅ Données récupérées pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("✅ DONNÉES MULTI-SYMBOLES CONFIRMÉES")
            else:
                logger.warning("Aucune donnée multi-symboles récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données multi-symboles: {e}")
        
        # 3. Vérifier l'accès aux données fondamentales
        logger.info("\n==== TEST DES DONNÉES FONDAMENTALES ====")
        try:
            logger.info(f"Récupération des données fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"✅ {len(news)} articles de news récupérés")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("✅ DONNÉES DE NEWS CONFIRMÉES")
            else:
                logger.warning("Aucune donnée de news récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données fondamentales: {e}")
        
        # 4. Résumé des résultats
        logger.info("\n==== RÉSUMÉ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a été testé pour les fonctionnalités suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. Données en temps réel")
        logger.info("3. Historique étendu (2+ ans)")
        logger.info("4. Données à haute résolution (minutes)")
        logger.info("5. Données multi-symboles")
        logger.info("6. Données fondamentales/news")
        
        logger.info("\nCes fonctionnalités sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configuré pour utiliser ces fonctionnalités premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÉRIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")



================================================
FILE: crypto_trader_log_20250508_121331.txt
================================================
〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㔱‹‭灡⹰瑵汩⹳湥彶潬摡牥ⴠ䤠䙎⁏‭潌摡湩⁧湥楶潲浮湥⁴慶楲扡敬⁳牦浯䌠尺牐橯捥獴䵜牥畣楲䅯屉攮癮㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳ㄬ㈶ⴠ愠灰甮楴獬攮癮江慯敤⁲‭义但ⴠ䄠灬捡⁡偁⁉牣摥湥楴污⁳潬摡摥猠捵散獳畦汬੹〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㘱′‭灡⹰瑵汩⹳湥彶潬摡牥ⴠ䤠䙎⁏‭潐祬潧⁮偁⁉敫⁹潬摡摥猠捵散獳畦汬੹〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㘱‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潃普杩牵⃩潰牵氠⁥牴摡湩⁧䅐䕐⁒猨浩汵瑡潩⥮㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳ㄬ㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠楴楬慳楴湯搠⁵楮敶畡搠愧潢湮浥湥⁴汁慰慣›਱〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㜱‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭汁慰慣牃灹潴牔摡牥椠楮楴污獩૩〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㠱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慭牲条⁥敤氠⁡敳獳潩⁮敤琠慲楤杮挠祲瑰⁯⃠〲㔲〭ⴵ㠰ㄠ㨲㌱㌺⸵㠱㌳㔸㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳ㄬ㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠⁡敳獳潩⁮敳琠牥業敮慲㈠㈰ⴵ㔰〭‸㘱ㄺ㨳㔳ㄮ㌸㠳ਵ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㤵‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潃灭整䄠灬捡⁡潣湮捥›㉤愹敦攲㜭㜹ⵡ搴ㄶ愭愸ⴷ〰戹ㅤ㠱㉤㔵㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㔬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲湩瑩慩敬搠⁵潰瑲晥略汩敬›㤤㔹㠰ㄮਲ਼〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㤵‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潍敤琠慲楤杮›䍁䥔䕖㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㜬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠楴楬慳楴湯搠甧敮氠獩整瀠牥潳湮污獩早搠⁥㐳猠浹潢敬⁳牣灹潴㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㜬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠數灭敬㩳䄠噁⽅单ⱄ䄠噁⽅单呄‬噁塁唯䑓‬䅂⽔单ⱄ䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㠬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠汯敤唠䑓搠獩潰楮汢㩥␠〱㐲⸱㘰㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㤬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠਠ㴽㴽‽义但䵒呁佉⁎啄䌠䵏呐⁅䱁䅐䅃㴠㴽㴽㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㤬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠汯敤搠獩潰楮汢㩥␠〲〷〴㠮ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㘹″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭楌畱摩瑩珩›ㄤ㈰ㄴ〮ਸ਼〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㘹‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹〵⸸㌱㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔳㤬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰵ㘹‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㘳㔬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰶ㔵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰶ㤷‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰶ㤷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳〬㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳〬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳㌬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳㌬㌲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳㔬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳㔬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰷ〸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㜳㠬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳〬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳〬㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰸ〳′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳㌬㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳㔬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳㔬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰸㄸ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㠳㠬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳〬㔶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳〬㔶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳㌬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳㌬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳㔬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㌺ⰹ㐵‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳㠬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㤳㠬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳〴ㄬ㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨳〴ㄬ㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰰ㔳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰰ㔳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰰㄶ‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱ㄺ㨳〴㘬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳〴㠬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰰ㘸‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨳ㄴㄬ㈱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱ㄺ㨳ㄴㄬ㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳ㄴ㌬㠵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰱ㔳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳ㄴ㘬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰱ〶″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳ㄴ㠬㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰱ㔸″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㤰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㤰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㌳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㌳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㈴㔬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㠵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㌸‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㈴㠬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㠴㠴㘲㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㈴㤬㜶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ传摲敲搠愧档瑡瀠慬瀠畯⁲剔䵕⽐单㩄㘠㡡㜹㌵ⴷ摣〲㐭㈵ⴴ㔸㤶㔭㤹㘳〰戴昱ਸ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰲ㘹‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰳ㜲‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮ㄸ਱〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰳ㜲‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㌴㔬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮㠷ਸ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰳ㘵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单䍄唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㌴㠬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㤮㤹ਸ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰳ㜸‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单呄唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㐴ㄬ㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ〮〰਴〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㐱‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剘⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㠳‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剘⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㈤ㄮ㜲ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㠳‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥员⽚单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㈶‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭员⽚单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㔮〴਴〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㈶‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰴ㜸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸵㠰㔹㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㐴㠬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰵ㈱‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㌸㠮〸ਰ〲㔲〭ⴵ㠰ㄠ㨲㌱㐺ⰵ㐲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵愠瑣敵汬⁥畤瀠牯整敦極汬㩥␠㤹㤴⸰㐷㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔴㌬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠獡搠⁥潰楳楴湯⁳畯敶瑲獥㈊㈰ⴵ㔰〭‸㈱ㄺ㨳㔴㌬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠瑴湥整搠⁥〶猠捥湯敤⁳癡湡⁴敬瀠潲档楡⁮祣汣⹥䘠湩搠⁥敳獳潩⁮慤獮㈠㤳洠湩瑵獥㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㔴㔬㐱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠਠ㴽㴽‽义但䵒呁佉⁎啄䌠䵏呐⁅䱁䅐䅃㴠㴽㴽㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㔴㔬㐱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠汯敤搠獩潰楮汢㩥␠〲〷〴㠮ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰵㄵ‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭楌畱摩瑩珩›㠤〰⸶㠹㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㔴㔬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲潴慴敬›㤤㐹ㄹ㘮ਲ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰵㄵ‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽਽㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㔴㔬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰵ〸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㘹㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㔴㠬㠰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㘴ㄬ㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㠸〵㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㘴ㄬ㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠䅖⽘单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶ㔳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭噁塁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤱㔮㌷ਵ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶ㔳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅂⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶ〶″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅂⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㠳ਸ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶㄶ‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶ㔸‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸㈮〷ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰶ㔸‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㜴〬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸ㄮ㜴ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㤰′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㔳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷ㄷ㔮㠵ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㔳′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㜴㘬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷㘳㌮㔱ਵ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㌶′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剃⽖单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㤸‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剃⽖单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㘶ਸ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰷ㤸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㠴ㄬ㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ਼〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸ㌱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸㄴ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸㄴ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸ㘶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㤮ㄷਲ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸ㘶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰸ㈹‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㈸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㠴㤬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰹ㘱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㤮㜶ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰹ㘱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥則⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰹㄴ‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭則⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮ㄹਵ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰹㄴ‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㤴㘬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㔸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㤴㘬㠵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㤴㤬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〴ਵ〲㔲〭ⴵ㠰ㄠ㨲㐱㐺ⰹ〹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰰ㘱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㠸〲㈊㈰ⴵ㔰〭‸㈱ㄺ㨴〵ㄬ㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰰ㘴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㜷ਲ〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰰ㘴‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䭍⽒单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰰ〷‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䭍⽒单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄵ⸷㜴〵㈊㈰ⴵ㔰〭‸㈱ㄺ㨴〵㜬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤倠偅⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰰ㔹‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䕐䕐唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴〵㤬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䥈⽂单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰱ㤱‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䡓䉉唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㈬〰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䱏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㐬㐴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䱏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㐱⸷㐴〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㐬㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㘬㠸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶㐲㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㘬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰱ㌹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶ㄲ㈊㈰ⴵ㔰〭‸㈱ㄺ㨴ㄵ㤬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤吠啒偍唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㈵㈬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠啒偍唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠〱㤮㘶ਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰲㄲ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥓乇䱁䐠䄧䡃呁›剔䵕⽐单⁄⃠ㄤ⸰㘹〶‬瑱㫩ㄠㄸ㐮㌵ㄱਰ〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰲ㌳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牏牤⁥❤捡慨⁴汰捡⃩潰牵吠啒偍唯䑓›㍤㐷㈱㔱戭㠹ⴸ戴慥戭㜶ⴷ昸愶摤ㄲ搴愹㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㈵㌬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㈵㔬㘸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㈵㔬㘸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰲ㈸‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㈵㠬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰳ㠰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵〬㈸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰳ㈳‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵㌬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵㔬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵㔬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵㠬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㌵㠬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㐵〬〷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰴ㜰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㐵㌬㜱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨴㐵㐬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹㐷〮਴〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰴ㔵″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㐱㔺ⰴ㔵″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‸業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰴ㤶‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰴ㤶‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㐵㘬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㜵㔷ㄮ਱〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰴ㤶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㜴⸴㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㐵㘬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰴ㤶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㐵㤬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰴ㐹‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰵ㘳′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰵ㘳″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㔵㘬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㔵㘬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㔵㠬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㔵㠬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵ㄬ㘷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵ㄬ㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰶ㈴‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵㐬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵㘬ㄷⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵㘬ㄷⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰶㄹ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㘵㤬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵ㄬ〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵ㄬ〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰷ〴‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵㐬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵㘬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵㘬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵㠬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㜵㠬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㠵ㄬ㌴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰸ㐱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㠵㌬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㠵㌬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㠵㘬㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㠵㘬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰸ㜸‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰸ㜸‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰹ㈱‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㤵ㄬ㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㤵㌬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰹ㠳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㤵㘬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㤵㘬㠷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨵㤵㤬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㔱㔺ⰹ㈹″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨶〰ㄬ㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰ㜱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨶〰㐬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰㄴ‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰ㠶″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰ㠶‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰ㈹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰰ㈹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㄰ㄬ㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰱ㘱‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰱㄴ‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㄰㐬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㈴㘲㈵㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㄰㔬㌴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ传摲敲搠愧档瑡瀠慬瀠畯⁲剔䵕⽐单㩄㠠㑢攲昷ⵦ㤹っ㐭ㄵⴹ㈹愱㜭㥡昵挹敤搴਴〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰱ㐵″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰱ㠷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮ㄸ਱〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰱ㤷‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㈰ㄬ㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮㠷ਸ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰲ㈱‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单䍄唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㈰㌬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㤮㤹ਸ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰲ㜳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单呄唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㈰㘬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ〮〰਴〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰲ㐶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剘⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰲㄹ‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剘⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㈤ㄮ㜲ਰ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰲㄹ‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥员⽚单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰳ㌲‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭员⽚单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㔮〴਴〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰳ㌲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰳ㠴‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸵㠰㔹㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㌰㐬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰳ㔷‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㌸㠮〸ਰ〲㔲〭ⴵ㠰ㄠ㨲㘱〺ⰳ㜸‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵愠瑣敵汬⁥畤瀠牯整敦極汬㩥␠㤹㔴⸸㠲㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㌰㤬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠獡搠⁥潰楳楴湯⁳畯敶瑲獥㈊㈰ⴵ㔰〭‸㈱ㄺ㨶㌰㤬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠瑴湥整搠⁥〶猠捥湯敤⁳癡湡⁴敬瀠潲档楡⁮祣汣⹥䘠湩搠⁥敳獳潩⁮慤獮㈠㜳洠湩瑵獥㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰ㄬ㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠਠ㴽㴽‽义但䵒呁佉⁎啄䌠䵏呐⁅䱁䅐䅃㴠㴽㴽㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰ㄬ㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠汯敤搠獩潰楮汢㩥␠〲〷〴㠮ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰴ㈱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭楌畱摩瑩珩›㌤㐵⸵㌴㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰ㄬ㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲潴慴敬›㤤㐹㠵㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰴ㈱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽਽㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰ㄬ㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰴ㜳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㘹㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰㌬㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰㘬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㠸〵㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㐰㘬㈳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠䅖⽘单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰴ㜸‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭噁塁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤱㔮㌷ਵ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰴ㜸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅂⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰵ㈱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅂⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㠳ਸ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰵ㈱‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰵ㘴‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸㈮〷ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰵ㘴‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㔰㜬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸ㄮ㜴ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰵ〷‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶ㜰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷ㄷ㔮㠵ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶ㜰′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㘰㌬㈱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷㘳㌮㔱ਵ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶㄳ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剃⽖单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶ㠵‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剃⽖单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㘶ਸ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶ㠵‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㘰㠬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ਼〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰶ㌸‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㜰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㜰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㘳‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㤮ㄷਲ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㘳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㘶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㈸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㜰㘬〷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㐹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㤮㜶ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰷ㐹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥則⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰸ㠱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭則⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮ㄹਵ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰸ㠱‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㠰㐬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㔸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㠰㐬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㠰㜬〰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〴ਵ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰸ〷‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰸ㐹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㠸〲㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㠰㤬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰹ〲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㜷ਲ〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰹ〲‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䭍⽒单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰹ㐴‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䭍⽒单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄵ⸷㜴〵㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㤰㐬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤倠偅⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰹ㐷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䕐䕐唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㤰㜬〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䥈⽂单੄〲㔲〭ⴵ㠰ㄠ㨲㜱〺ⰹ㤹‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䡓䉉唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㤰㤬㜹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䱏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷〱㈬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䱏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㐱⸷㐴〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨷〱㈬㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷〱㔬㠳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶㐲㈊㈰ⴵ㔰〭‸㈱ㄺ㨷〱㔬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰰ㤷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶ㄲ㈊㈰ⴵ㔰〭‸㈱ㄺ㨷〱㜬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤吠啒偍唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷ㄱ〬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠啒偍唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠〱㤮㘶ਰ〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰱ㜰′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥓乇䱁䐠䄧䡃呁›剔䵕⽐单⁄⃠ㄤ⸰㘹〶‬瑱㫩ㄠㄸ㌮㌹〹ਸ〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰱㄲ‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牏牤⁥❤捡慨⁴汰捡⃩潰牵吠啒偍唯䑓›㤸㡢㍡㈱㠭㈶ⵥ愴愳㠭㤷ⴱ㈱摥づ㤲捤愹㈊㈰ⴵ㔰〭‸㈱ㄺ㨷ㄱ㈬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷ㄱ㐬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱ㄺ㨷ㄱ㐬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰱㄷ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨷ㄱ㜬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰲ㄰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱〬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰲ㘲‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱㈬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱㔬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱㔬㐱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱㠬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㈱㠬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㌱〬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰳ㔰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㌱㌬㐰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨷㌱㐬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㘮ਹ〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰳ㔵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㜱ㄺⰳ㔵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‶業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰳ㤶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰳ㤶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌱㘬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰳ㤶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㐴⸰㐷㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌱㘬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰳ㤶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌱㤬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰳ㐹‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰴ㐲‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰴ㐲‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㐱㘬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㐱㘬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㐱㤬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㐱㤬㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱ㄬ㘷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱ㄬ㘷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰵ㈴‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱㐬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱㘬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱㘬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰵ㔹‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㔱㤬㠵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㘱㈬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㘱㈬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰶ㌶‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㘱㘬㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㘱㤬㠱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㘱㤬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱ㄬ〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱ㄬ〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱㐬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰷ〴‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱㘬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱㘬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱㤬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㜱㤬〲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰸ㤱′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰸ㤱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰸ㘴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㠱㐬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㠱㜬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰸ㈷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㤱〬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㤱〬㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㤱㐬㌴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰹ㐴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㤱㜬〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰹ㔷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㤱㤬〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱ㄺⰹ㤹′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰰ㌲‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰰ㌲‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰰ㠴‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰰ㠴‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨸〲㜬㐹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰰ㤷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰱㄱ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲㄬ㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㠱㜲㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲ㈬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㐸㘮ⰱ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲ㈬㠳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲ㔬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲ㔬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰱ㤷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨸ㄲ㜬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰲ㌰‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲〬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰲ㜲‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲㈬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲㔬㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲㔬㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲㜬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㈲㜬㌷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌲〬㌲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰳ㈰‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌲㈬㔶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨸㌲㌬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㜮਴〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰳ㤴‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㠱㈺ⰳ㤴‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‵業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰳ㌶‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰳ㌶‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㌲㘬〳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰳ㌶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㐴⸰㐷㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㌲㘬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰳ㌶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㌲㠬㈸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰳ㠸″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰴ㈱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰴ㈱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㌬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㌬㜶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㘬〲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㘬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㠬㌷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㐲㠬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰵㄱ‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲ㄬ㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲㌬㔶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲㌬㔶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰵ〶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲㘬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲㠬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㔲㠬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰶ㈱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲ㄬㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲㌬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲㌬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲㘬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲㘬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㘲㠬㐴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰶ㐸‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㜲〬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㜲〬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㜲㐬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㜲㐬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰷ㜶‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰷ㜶‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰷ㈹′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㜲㤬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㠲ㄬ㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰸ㘱‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㠲㐬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㠲㐬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㠲㘬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰸ㠶‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㠲㤬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰸ㌹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㤲ㄬㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㠱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㈴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㈴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㜶′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㜶″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㤲㤬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㤱㈺ⰹ㈹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰰ㘱‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳ㄬ〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㤱㤱㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳㈬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㠷㐮ⰹ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳㈬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳㔬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳㔬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰰ㤷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱ㄺ㨹〳㠬〰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰱ㐰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ〬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰱ㤲‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ㈬㤹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ㔬㜹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ㔬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ㠬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱ㄺ㨹ㄳ㠬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㈳ㄬ㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰲㄱ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㈳㌬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱ㄺ㨹㈳㐬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㜮਴〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰲ㈶′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㤱㌺ⰲ㈶′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‴業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰲ㠷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰲ㠷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨰㈳㜬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰲ㠷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㐴⸰㐷㈊㈰ⴵ㔰〭‸㈱㈺㨰㈳㜬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰲ㠷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㌳〬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰳ㌰′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰳ㜲‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰳ㜲‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㌳㔬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨰㌳㔬㜱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㌳㠬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨰㌳㠬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳〬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳〬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰴ㐳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳㌬ㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳㔬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳㔬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰴ㌸″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨰㐳㠬㌳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳〬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳〬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰵ㈳″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳㌬㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳㔬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳㔬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳㠬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨰㔳㠬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㘳〬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰶ㘰‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨰㘳㌬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨰㘳㌬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㘳㔬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨰㘳㔬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰶ〸″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰶ〸‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰷ㘰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨰㜳〬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㜳㌬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰷㄳ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨰㜳㔬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨰㜳㔬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㜳㠬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰷ〸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㠳〬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㐰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㠳㈬㌹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㤲‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㌵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㌵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㔸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰸ㔸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳ㄬ㐰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰹ〱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲〲㌺ⰹ㔳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳㌬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㤱㤱㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳㔬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㈷㌮ⰵ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳㔬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳㜬㠷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨰㤳㜬㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰰ㘰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨰〴〬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰰ㐳‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨰〴㌬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰰ㠵‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨰〴㔬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰〴㠬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨰〴㠬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰ㄴ〬㔹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨰ㄴ〬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨰ㄴ㌬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰱ㌳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨰ㄴ㘬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨰ㄴ㠬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㜮਴〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰲ〰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲〲㐺ⰲ〰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲′業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨱㈴ㄬ㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㐴⸰㐷㈊㈰ⴵ㔰〭‸㈱㈺㨱㈴ㄬ㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㈴㐬〳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㌴‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜶‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰲ㜶‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㈴㤬㤴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨱㈴㤬〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㌴㈬㌲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨱㌴㈬㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㌴㔬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨱㌴㔬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰳ〸‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨱㌴㠬㠰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴〬㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴〬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰴ〳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴㌬㠰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴㔬〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴㔬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰴㄸ‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨱㐴㠬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴〬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴〬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴㌬㄰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴㌬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴㔬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰵ㐵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴㜬㔹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨱㔴㜬㔹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㘴〬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨱㘴〬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰶ〳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰶ〳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰶ㠵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨱㘴㔬〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㘴㤬㤹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰶ㤹‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨱㜴㌬〳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨱㜴㌬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㜴㘬〴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰷ㐶‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㜴㠬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰷ㠸‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㠴ㄬ㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㈱‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㈴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㈴‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㤶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㤶‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨱㠴㤬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰸ㐹′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰹ㤱‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴ㄬ〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㤱㤱㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴㌬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㔷㌮ⰷ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴㌬〲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴㔬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴㔬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲ㄲ㐺ⰹㄸ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨱㤴㠬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㔺ⰰ㔰‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨱〵〬㠵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲ㄲ㔺ⰰ〳′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨱〵㌬㈰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱〵㔬ㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨱〵㔬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱〵㜬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨱〵㜬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨱ㄵ〬ㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㔺ⰱ㐰‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨱ㄵ㈬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨱ㄵ㐬㠰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㜮਴〲㔲〭ⴵ㠰ㄠ㨲ㄲ㔺ⰱ㌵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲ㄲ㔺ⰱ㌵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‱業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰱ㘶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰱ㘶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨲ㄵ㘬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰱ㘶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㐴⸰㐷㈊㈰ⴵ㔰〭‸㈱㈺㨲ㄵ㘬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰱ㘶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲ㄵ㤬㜱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰱㄹ‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰲ㔱‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰲ㘱‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㐬㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㐬㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㘬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㘬㈸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㤬㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨲㈵㤬㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰳ㜱‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨲㌵ㄬ㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㌵㜬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨲㌵㜬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰳ㤹‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨲㌵㤬㔹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㈬〴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㈬ㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰴ㠴‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㐬㤸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㜬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㜬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㤬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨲㐵㤬ㄸⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㔵㈬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰵ㈲′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨲㔵㐬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨲㔵㐬〷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㔵㜬㠱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨲㔵㜬㤱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰵ㘹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰵ㘹‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰶㄲ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨲㘵㈬㐱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㘵㐬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰶ㠴‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨲㘵㜬㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨲㘵㜬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㜵㈬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰷ〲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㜵㐬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰷ㐴‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㜵㠬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰷㄸ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸ㘰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸ㘰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸㄳ‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸㄳ‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨲㠵㘬㌴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸ㐶″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰸ㠸‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨲㠵㠬㜸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㤱㤱㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵〬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㔷㌮ⰷ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵〬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵㈬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵㈬㘵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰹ〵‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵㔬㠰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰹ㔷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵㜬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㈲㔺ⰹ㤹‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨲㤵㤬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㈬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㈬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㔬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㔬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㜬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㌲〺ⰰ㔷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨳〰㤬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨳㄰ㄬ〲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹〴㜮਴〲㔲〭ⴵ㠰ㄠ㨲㌲〺ⰱ㌲‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㌲〺ⰱ㌲‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㌲‰業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨴㄰㌬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㌴⸹㈸㈊㈰ⴵ㔰〭‸㈱㈺㨴㄰㌬㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜳‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㄰㘬㜲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㈶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜸‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰱ㜸‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰ㄬ〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰ㄬ〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰㌬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰㌬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰㘬㐰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰㘬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰲ㤸‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨴㈰㤬㄰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰ㄬ㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰ㄬ㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰳ㈴′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰㐬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰㘬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰㘬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰳ㈹‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨴㌰㤬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰ㄬㄷⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰ㄬ㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰㐬〱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰㐬㈱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰㘬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰴ㔶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰㠬㜹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨴㐰㠬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㔰ㄬ㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨴㔰ㄬ〴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰵ㠳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰵ㠳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰵ㔶‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨴㔰㘬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㔰㠬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰵ㤸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨴㘰ㄬ㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨴㘰ㄬ㤴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㘰㐬㘸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰶ㠴‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㘰㜬㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰶ㌷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㘰㤬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰶ㜹‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷ㈲″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷ㈲″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷㄵ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷㄵ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨴㜰㜬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷ㔷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰷ㤹‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨴㜰㤬㤹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㤱㤱㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰ㄬ㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㠷㔮ⰹ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰ㄬ㐲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰㌬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰㌬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰸ㌶‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰㘬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰸ㜸‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨴㠰㠬㐷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰹ㠱′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰ㄬ㌸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰㐬㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰㐬㔲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰㘬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰㘬〷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨴㤰㤬ㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㐲〺ⰹ㈹″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨴〱ㄬ㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨴〱㈬㠸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹㤳㠮ਲ〲㔲〭ⴵ㠰ㄠ㨲㐲ㄺⰰ〴″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㐲ㄺⰰ〴‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㈲‹業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰰ㔵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰰ㔵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨵〱㔬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰰ㔵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㌴⸹㈸㈊㈰ⴵ㔰〭‸㈱㈺㨵〱㔬㘵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰰ㔵‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵〱㠬㈳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰰ㌸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰱ㜰‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰱ㜰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㐬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㐬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㜬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㜬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㤬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨵ㄱ㤬㐶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰲㄲ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨵㈱㈬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㈱㔬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨵㈱㔬㤴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰲ㠷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨵㈱㜬㠸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱〬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱〬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰳ㠲‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱㈬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱㔬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱㔬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱㜬㈹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨵㌱㜬㌹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㐱〬㈳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰴ㌰″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨵㐱㈬㠷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨵㐱㈬㠷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㐱㔬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨵㐱㔬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰴ㤷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰴ㤷‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰵ㌰‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨵㔱〬〴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㔱㈬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰵ㠲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨵㔱㔬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨵㔱㔬〳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㔱㜬㈷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰵ㜷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㘱〬㘱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ㄰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㘱㈬㠵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ㔲‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ〵‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ〵′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ㐷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ㐷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨵㘱㤬㜸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰶ㠹‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰷ㌲‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㈬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㈰ㄴ㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㌬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㠷㤮ⰷ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㌬㌶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㘬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㘬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰷ㐸‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨵㜱㠬㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰸ㔱′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱ㄬ㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰸㄴ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱㐬㔱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱㘬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱㘬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱㤬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨵㠱㤬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨵㤱㈬㘰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰹ〲‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨵㤱㔬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨵㤱㘬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹㤳㠮ਲ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰹ㐷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㔲ㄺⰹ㐷‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㈲‸業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㘲ㄺⰹㄹ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㘲ㄺⰹㄹ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨶㤱㤬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㘲ㄺⰹㄹ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㌴⸹㈸㈊㈰ⴵ㔰〭‸㈱㈺㨶㤱㤬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㘲ㄺⰹㄹ″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶〲ㄬ㜶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰰ㘱‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰰㄴ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰰㄴ‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶〲㘬㤵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨶〲㘬㤵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶〲㤬㄰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨶〲㤬㄰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲㄬ㤴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲㄬ〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰱ㤳‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲ㌬㜹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲ㘬㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲ㘬〴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰱ㈹‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨶ㄲ㤬㠲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲ㄬ㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲ㄬ㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰲ㘴‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲㐬㘶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲㜬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲㜬㐱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲㤬㘵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨶㈲㤬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㌲㈬㤲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰳ㈲‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨶㌲㐬㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨶㌲㐬㜷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㌲㠬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨶㌲㠬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰴ㘰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰴ㘰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰴ㌳‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨶㐲㌬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㐲㔬㌸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰴ㠵″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨶㐲㠬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨶㐲㠬㐳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㔲ㄬ㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰵ㐱‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㔲㐬㐰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰵ〴‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㔲㘬㔵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰵ㔶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰵ㤸‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰵ〹‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰶ㐱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰶ㐱‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨶㘲㌬〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰶ㤳‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰶ㘶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨶㘲㘬㠶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㈰ㄴ㈊㈰ⴵ㔰〭‸㈱㈺㨶㘲㜬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㜷㈮‬癡楡慬汢㩥ㄠㄳ⸴㠲਩〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰶ㤷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰷ㌰″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮ㄸ਱〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰷ㌰″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥乕⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨶㜲㈬〸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㐤㠮㠷ਸ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰷ㠲‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单䍄唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㜲㔬〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㤮㤹ਸ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰷ㤵‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥单呄唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨶㜲㠬㈶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䑓⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ〮〰਴〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰷ㘸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剘⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ〱‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剘⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㈤ㄮ㜲ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ〱‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥员⽚单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ㌴‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭员⽚单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㔮〴਴〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ㌴‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ㈷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸵㠰㔹㈊㈰ⴵ㔰〭‸㈱㈺㨶㠲㜬㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰸ㜹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䙙⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㌸㠮〸ਰ〲㔲〭ⴵ㠰ㄠ㨲㘲㈺ⰹ㤰‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵愠瑣敵汬⁥畤瀠牯整敦極汬㩥␠㤹㌴⸹㈸㈊㈰ⴵ㔰〭‸㈱㈺㨶㤲㈬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠獡搠⁥潰楳楴湯⁳畯敶瑲獥㈊㈰ⴵ㔰〭‸㈱㈺㨶㤲㈬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠瑴湥整搠⁥〶猠捥湯敤⁳癡湡⁴敬瀠潲档楡⁮祣汣⹥䘠湩搠⁥敳獳潩⁮慤獮㈠㜲洠湩瑵獥㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㌬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠਠ㴽㴽‽义但䵒呁佉⁎啄䌠䵏呐⁅䱁䅐䅃㴠㴽㴽㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㌬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠汯敤搠獩潰楮汢㩥␠〲〷〴㠮ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㈺ⰹ㘳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭楌畱摩瑩珩›ㄤㄳ⸴㠲㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㌬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲潴慴敬›㤤㐹㤳㠮ਲ〲㔲〭ⴵ㠰ㄠ㨲㜲㈺ⰹ㘳‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽਽㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㌬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㈺ⰹㄶ′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㘹㔱㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㘬㌱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠噁⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㠬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜱⸲㠸〵㈊㈰ⴵ㔰〭‸㈱㈺㨷㤲㠬㔸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䄠䅖⽘单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㠱′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭噁塁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤱㔮㌷ਵ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㠱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅂⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㠴‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅂⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㠳ਸ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㠴‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㌷‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸㈮〷ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㌷‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䍂⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨷〳㤬㘸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㘸ㄮ㜴ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰰ㠹‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰱ㠲‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷ㄷ㔮㠵ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰱ㠲‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呂⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨷ㄳ㔬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㤤〷㘳㌮㔱ਵ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰱ㔵‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剃⽖单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰱ〸‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剃⽖单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㘶ਸ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰱ〸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㈳〬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ਼〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲ㔰″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄䕇唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲㄳ‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤ㄮ㈷ਲ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲㄳ‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥佄⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲ㘵‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㌤㤮ㄷਲ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲ㘵‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰲㄸ‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㈸〰㈊㈰ⴵ㔰〭‸㈱㈺㨷㈳㠬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰳ㌱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呅⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㤮㜶ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰳ㌱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥則⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰳ㤳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭則⽔单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮ㄹਵ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰳ㤳‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㌳㘬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㔸〰㈊㈰ⴵ㔰〭‸㈱㈺㨷㌳㘬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单呄㈊㈰ⴵ㔰〭‸㈱㈺㨷㌳㠬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠义⽋单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〴ਵ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰳ㤸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰴ㌱‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㠸〲㈊㈰ⴵ㔰〭‸㈱㈺㨷㐳ㄬ㤳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰴ㤴‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呌⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㜷ਲ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰴ㤴‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䭍⽒单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰴ㜷‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䭍⽒单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄵ⸷㜴〵㈊㈰ⴵ㔰〭‸㈱㈺㨷㐳㜬㔷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤倠偅⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰵ㄰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䕐䕐唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳〬㠱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䥈⽂单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰵ㘲‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䡓䉉唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〰〰㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳㈬ㄶⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠䱏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳㘬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䱏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㐱⸷㐴〶㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳㘬㔰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳㠬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶㐲㈊㈰ⴵ㔰〭‸㈱㈺㨷㔳㠬㜴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤匠单䥈唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰶ㤰‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰〶ㄲ㈊㈰ⴵ㔰〭‸㈱㈺㨷㘳〬㘹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤吠啒偍唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㘳㌬㜵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠啒偍唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠〱㤮㘶ਰ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰶ㔳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥓乇䱁䐠䄧䡃呁›剔䵕⽐单⁄⃠ㄤ⸰㘹〶‬瑱㫩ㄠㄸ㌮〶㐲਱〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰶ〵‶‭污慰慣损祲瑰彯牴摡牥ⴠ䔠剒剏ⴠ䔠牲略⁲❤硥揩瑵潩⁮❤捡慨⁴潰牵吠啒偍唯䑓›湩畳晦捩敩瑮戠污湡散映牯唠䑓⠠敲畱獥整㩤㈠㜲⸴ⰹ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨷㘳㔬㜰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㘳㤬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨷㘳㤬㈵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰷ㤱‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨷㜳ㄬ㐹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰷ㔴‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨷㜳㐬〵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰷ㤶‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨷㜳㘬㐹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㜳㤬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨷㜳㤬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㠳㈬㔴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨷㠳㈬㘴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨷㠳㔬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰸ㌵‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨷㠳㜬㜹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨷㠳㤬㠱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹㤳㠮ਲ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰹ㌰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㜲㌺ⰹ㌰‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㈲‵業畮整ੳ〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㠱′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭㴊㴽㴽䤠䙎剏䅍䥔乏䐠⁕佃偍䕔䄠偌䍁⁁㴽㴽਽〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㠱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭潓摬⁥楤灳湯扩敬›㈤㜰㐰⸰〸㈊㈰ⴵ㔰〭‸㈱㈺㨸㤳ㄬ㌸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠煩極楤㩳␠㌱㐱㈮ਸ〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㠱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慖敬牵琠瑯污㩥␠㤹㌴⸹㈸㈊㈰ⴵ㔰〭‸㈱㈺㨸㤳ㄬ㌸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ㴠㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽㴽ਊ〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㠱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㤳㐬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠噁⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㤮ㄶਵ〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㌴′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䅁䕖唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㜶‵‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䅁䕖唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㈷㠮㔸ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㌺ⰹ㜶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥噁塁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㤳㤬ㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䄠䅖⽘单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸹㜵㔳㈊㈰ⴵ㔰〭‸㈱㈺㨸㤳㤬㈴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠呁唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸〴㌬㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠呁唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㌱㠸㈊㈰ⴵ㔰〭‸㈱㈺㨸〴㌬㌰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸〴㘬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䡃唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㜲〰㈊㈰ⴵ㔰〭‸㈱㈺㨸〴㘬㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䡃唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰰ㤸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䍂⽈单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠳⸶㐱〷㈊㈰ⴵ㔰〭‸㈱㈺㨸〴㠬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴㄬㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䈠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㜰⸱㔵〸㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴㄬㄴⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䈠䍔唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰱ㠳‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭呂⽃单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㜹㌰⸶ㄳ㔵㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴ㌬㐸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䌠噒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴ㘬㌵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䌠噒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㘶㠶㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴ㘬㐵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰱ㤸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭佄䕇唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㌲㈊㈰ⴵ㔰〭‸㈱㈺㨸ㄴ㠬㌹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠䝏⽅单呄㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴ㄬ㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠䝏⽅单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㜱㈲㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴ㄬ㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䐠呏唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴㌬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䐠呏唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸳㜹㈱㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴㌬ㄹⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䔠䡔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴㘬㔳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㠱㈱㠮〲ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰲ㌶‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呅⽈单呄㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴㠬㠷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䔠䡔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤㄸ⸲㘹〷㈊㈰ⴵ㔰〭‸㈱㈺㨸㈴㠬㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䜠呒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㌴ㄬㄲⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䜠呒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤰㔱㈊㈰ⴵ㔰〭‸㈱㈺㨸㌴ㄬ㈲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠义⽋单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰳ㜳′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㌱㠮〵ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰳ㜳″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䥌䭎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰳ㠷′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭䥌䭎唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸳㐸㔰㈊㈰ⴵ㔰〭‸㈱㈺㨸㌴㜬㈸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䰠䍔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㐴〬㘳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㤸㠮㈸ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰴ㌰‶‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥呌⽃单呄㈊㈰ⴵ㔰〭‸㈱㈺㨸㐴㌬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䰠䍔唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㠤⸹㜸㈷㈊㈰ⴵ㔰〭‸㈱㈺㨸㐴㌬㘲ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤䴠剋唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㐴㔬㤶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ䴠剋唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠㔱㜱㐮㔷ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰴ㘵‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䕐䕐唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㐴㠬ㄵⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ倠偅⽅单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰴ㔸′‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䡓䉉唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㔴ㄬ㄰ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䥈⽂单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤〮〰ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ〱‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥体⽌单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ㐳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭体⽌单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ㜴㐮㘴ਰ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ㐳‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ㌷‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭啓䡓⽉单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਴〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ㌷‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥啓䡓⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨸㔴㤬㌸ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠单䥈唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›〤㘮㈰਱〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰵ㠹‴‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥剔䵕⽐单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰶ㌲‱‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭剔䵕⽐单⁄牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›ㄤ⸰㘹〶㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㈬ㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ匠䝉䅎⁌❄䍁䅈㩔吠啒偍唯䑓␠〱㤮㘶ⰰ焠›㠱⸱㘳㈰ㄴ㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㌬㤵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭剅佒⁒‭牅敲牵搠攧畣楴湯搠愧档瑡瀠畯⁲剔䵕⽐单㩄椠獮晵楦楣湥⁴慢慬据⁥潦⁲单⁄爨煥敵瑳摥›㈲㌷㠮ⰷ愠慶汩扡敬›㌱㐱㈮⤸㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㌬〶ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㘬ㄱⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ唠䥎唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㠸ㄱ㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㘬㈱ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䥎唯䑓੔〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰶ㤸‷‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭乕⽉单呄瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸴㜸㠸㈊㈰ⴵ㔰〭‸㈱㈺㨸㘴㠬㠹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽃单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰷ㐱‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单䍄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㤹㠹㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴ㄬ㠴ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤唠䑓⽔单੄〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰷ㠳‹‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭单呄唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸱〰㐰㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴㌬〹ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠偒唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴㘬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠偒唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸲㈱〷㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴㘬㜳ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤堠婔唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴㠬㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ堠婔唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠⸰㐵㐰㈊㈰ⴵ㔰〭‸㈱㈺㨸㜴㠬㤷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ吠慲瑩浥湥⁴敤夠䥆唯䑓㈊㈰ⴵ㔰〭‸㈱㈺㨸㠴ㄬㄳⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓瀠楲⁸捡畴汥⠠敤湲敲戠牡敲㨩␠ㄵ㔸〮㤸ਵ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰸ㌱″‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭牔楡整敭瑮搠⁥䙙⽉单呄㈊㈰ⴵ㔰〭‸㈱㈺㨸㠴㌬㌷ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ夠䥆唯䑓⁔牰硩愠瑣敵⁬搨牥楮狨⁥慢牲⥥›㔤㠱⸳㠸〰㈊㈰ⴵ㔰〭‸㈱㈺㨸㠴㔬㤵ⴠ愠灬捡彡牣灹潴瑟慲敤⁲‭义但ⴠ嘠污略⁲捡畴汥敬搠⁵潰瑲晥略汩敬›㤤㐹㤳㠮ਲ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰸ㜶‸‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭慐⁳敤瀠獯瑩潩獮漠癵牥整ੳ〲㔲〭ⴵ㠰ㄠ㨲㠲㐺ⰸ㠶‰‭污慰慣损祲瑰彯牴摡牥ⴠ䤠䙎⁏‭瑁整瑮⁥敤㘠‰敳潣摮獥愠慶瑮氠⁥牰捯慨湩挠捹敬‮楆⁮敤猠獥楳湯搠湡⁳㈲‴業畮整ੳ


================================================
FILE: custom_crypto_symbols.txt
================================================
BTCUSD
ETHUSD
SOLUSD
AVAXUSD
LINKUSD
XRPUSD
DOTUSD
DOGEUSD
MATICUSD
AAVEUSD
UNIUSD
SHIBUD
MKRUSD
LTCUSD
BCHUSD
GRTUSD
XTZUSD
CRVUSD
PEPEUD
SUSHIUSD



================================================
FILE: custom_crypto_symbols_new.txt
================================================
BTC/USD
ETH/USD
SOL/USD
AVAX/USD
LINK/USD
XRP/USD
DOT/USD
DOGE/USD
MATIC/USD
AAVE/USD
UNI/USD
SHIB/USD
MKR/USD
LTC/USD
BCH/USD
GRT/USD
XTZ/USD
CRV/USD
PEPE/USD
SUSHI/USD



================================================
FILE: custom_strategy_lstm_params.json
================================================
{
  "strategy_type": "lstm",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "lstm_units": 50,
    "dropout_rate": 0.2,
    "epochs": 50,
    "batch_size": 32,
    "use_gpu": true,
    "retrain": true,
    "position_size": 0.03,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_mean_reversion_params.json
================================================
{
  "strategy_type": "mean_reversion",
  "params": {
    "lookback_period": 20,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_momentum_params.json
================================================
{
  "strategy_type": "momentum",
  "params": {
    "lookback_period": 20,
    "position_size": 0.02,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_moving_average_ml_params.json
================================================
{
  "strategy_type": "moving_average_ml",
  "params": {},
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_stat_arb_params.json
================================================
{
  "strategy_type": "stat_arb",
  "params": {
    "volatility_lookback": 10,
    "position_size": 0.02,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_transformer_params.json
================================================
{
  "strategy_type": "transformer",
  "params": {
    "sequence_length": 120,
    "prediction_horizon": 1,
    "d_model": 128,
    "nhead": 8,
    "num_layers": 3,
    "dropout": 0.1,
    "signal_threshold": 0.7,
    "use_gpu": true,
    "retrain": false,
    "position_size": 0.005,
    "stop_loss": 0.01,
    "take_profit": 0.03
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: data_generator.py
================================================
"""
Mercurio AI - Data Generator

This module generates realistic market data for January 2025
to be used with the trading strategy simulations.
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os

def generate_market_data(symbol, start_date, end_date, initial_price=None, volatility=None):
    """
    Generate realistic OHLCV market data for a symbol.
    
    Args:
        symbol: The market symbol (e.g., 'AAPL', 'BTC-USD')
        start_date: Start date for generated data
        end_date: End date for generated data
        initial_price: Starting price (if None, uses a realistic default)
        volatility: Price volatility (if None, uses realistic default based on symbol)
    
    Returns:
        DataFrame with columns: date, open, high, low, close, volume
    """
    # Set realistic initial prices and volatility if not provided
    if initial_price is None:
        price_defaults = {
            'AAPL': 190.0, 'MSFT': 410.0, 'GOOGL': 160.0, 'AMZN': 180.0, 'TSLA': 175.0,
            'BTC-USD': 42000.0, 'ETH-USD': 2200.0, 'SOL-USD': 95.0, 'ADA-USD': 0.45, 'DOT-USD': 7.0
        }
        initial_price = price_defaults.get(symbol, 100.0)
    
    if volatility is None:
        # Higher volatility for crypto
        if '-USD' in symbol:
            volatility = 0.025  # 2.5% daily volatility for crypto
        else:
            volatility = 0.015  # 1.5% daily volatility for stocks
    
    # Generate date range (exclude weekends for stocks)
    date_range = []
    current_date = start_date
    is_crypto = '-USD' in symbol
    
    while current_date <= end_date:
        # For stocks, skip weekends
        if is_crypto or current_date.weekday() < 5:  # 0-4 are Monday to Friday
            date_range.append(current_date)
        current_date += timedelta(days=1)
    
    # Ensure at least 3 rows of data for simulation
    min_rows = 3
    if len(date_range) < min_rows:
        # Extend backwards in time if needed
        print(f"[WARNING] Not enough data points for {symbol} between {start_date} and {end_date}. Auto-extending date range to ensure at least {min_rows} data points.")
        needed = min_rows - len(date_range)
        ext_date = (date_range[0] if date_range else end_date)
        ext_dates = []
        while len(ext_dates) < needed:
            ext_date = ext_date - timedelta(days=1)
            if is_crypto or ext_date.weekday() < 5:
                ext_dates.insert(0, ext_date)
        date_range = ext_dates + date_range
    
    # Generate price data using geometric Brownian motion
    n_days = len(date_range)
    returns = np.random.normal(0, volatility, n_days)
    
    # Add a slight drift (upward bias for January 2025)
    drift = 0.001  # 0.1% daily drift
    returns = returns + drift
    
    # Calculate price series
    prices = [initial_price]
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    # Generate realistic OHLCV data
    data = []
    for i, date in enumerate(date_range):
        close_price = prices[i]
        high_low_range = close_price * volatility * 1.5
        
        # Ensure first day price matches initial_price for the close
        if i == 0:
            close_price = initial_price
            
        open_price = prices[i-1] if i > 0 else close_price * (1 - volatility/2)
        high_price = max(open_price, close_price) + np.random.uniform(0, high_low_range)
        low_price = min(open_price, close_price) - np.random.uniform(0, high_low_range)
        
        # Generate volume (higher for more volatile days)
        price_change = abs(close_price - open_price)
        base_volume = close_price * 1000  # Base volume proportional to price
        volume = int(base_volume * (1 + 5 * price_change / close_price))
        
        data.append({
            'date': date,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume
        })
    
    df = pd.DataFrame(data)
    df.set_index('date', inplace=True)
    
    return df

def save_market_data(symbol, data, directory='data'):
    """Save market data to CSV file."""
    os.makedirs(directory, exist_ok=True)
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    data.to_csv(filename)
    print(f"Saved data for {symbol} to {filename}")
    return filename

def generate_all_market_data(symbols, start_date, end_date, directory='data'):
    MIN_ROWS = 10
    for symbol in symbols:
        print(f"Generating data for {symbol}...")
        data = generate_market_data(symbol, start_date, end_date)
        tries = 0
        while (data is None or len(data) < MIN_ROWS) and tries < 5:
            start_date = start_date - timedelta(days=5)
            data = generate_market_data(symbol, start_date, end_date)
            tries += 1
        if data is not None and len(data) >= MIN_ROWS:
            filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
            data.to_csv(filename)
            print(f"Saved data for {symbol} to {filename}")
        else:
            print(f"Failed to generate sufficient data for {symbol} (rows: {len(data) if data is not None else 0})")

def load_market_data(symbol, directory='data'):
    """Load market data from CSV file."""
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    if os.path.exists(filename):
        data = pd.read_csv(filename)
        data['date'] = pd.to_datetime(data['date'])
        data.set_index('date', inplace=True)
        return data
    else:
        return None

if __name__ == "__main__":
    # Test the data generator
    symbols = ['AAPL', 'MSFT', 'GOOGL', 'BTC-USD', 'ETH-USD']
    start_date = datetime(2025, 1, 1)
    end_date = datetime(2025, 1, 31)
    
    files = generate_all_market_data(symbols, start_date, end_date)
    print(f"Generated data files: {files}")
    
    # Load and display sample data
    aapl_data = load_market_data('AAPL')
    if aapl_data is not None:
        print("\nSample AAPL data:")
        print(aapl_data.head())



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  worker:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app worker --loglevel=info

  beat:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app beat --loglevel=info

  flower:
    build: .
    ports:
      - "5555:5555"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app flower

  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=mercurio

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:



================================================
FILE: Dockerfile
================================================
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create directories
RUN mkdir -p ./logs ./data ./models

# Expose port
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]



================================================
FILE: gitingest
================================================
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>🚀 Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## 💼 Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### 🌟 Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## 📂 Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
├── app/                       # Core application directory
│   ├── main.py                # FastAPI application entry point
│   ├── api/                   # API endpoints
│   │   ├── routes.py          # API route definitions
│   │   └── schemas.py         # Pydantic models for requests/responses
│   ├── services/              # Business logic services
│   │   ├── market_data.py     # Service for fetching market data
│   │   ├── trading.py         # Service for executing trades
│   │   └── backtesting.py     # Service for backtesting strategies
│   ├── strategies/            # Trading strategies
│   │   ├── base.py            # Base strategy class
│   │   ├── moving_average.py  # Moving Average Crossover strategy
│   │   ├── lstm_predictor.py  # LSTM-based prediction strategy
│   │   ├── transformer.py     # Transformer-based strategy
│   │   ├── llm_strategy.py    # LLM-powered strategy
│   │   └── msi_strategy.py    # Market Sentiment Index strategy
│   ├── db/                    # Database modules
│   │   ├── database.py        # Database connection
│   │   └── models.py          # SQLAlchemy models
│   ├── tasks/                 # Celery tasks
│   │   ├── celery_app.py      # Celery configuration
│   │   ├── training.py        # Tasks for model training
│   │   ├── trading.py         # Tasks for automated trading
│   │   └── data.py            # Tasks for data collection
│   └── utils/                 # Utility functions
├── docs/                      # Documentation directory
│   ├── for-dummies/           # Comprehensive guide for beginners
│   ├── guides/                # Specialized guides
│   │   ├── beginner/          # Beginner guides
│   │   └── advanced/          # Advanced guides
│   ├── api/                   # API documentation
│   ├── reference/             # Technical reference
│   └── README.md              # Documentation index
├── models/                    # Saved ML models
│   ├── lstm/                  # LSTM models and scalers
│   └── transformer/           # Transformer models and scalers
├── data/                      # Data directory
│   └── sample_data/           # Sample data for testing
├── reports/                   # Reports and visualizations
│   ├── comprehensive/         # Comprehensive simulation results
│   └── visualizations/        # Generated charts and graphs
├── tests/                     # Tests directory
├── comprehensive_simulation.py # Full-featured simulation script
├── strategy_dashboard.py      # Streamlit dashboard for strategy visualization
├── docker-compose.yml         # Docker Compose configuration
├── Dockerfile                 # Docker configuration
├── requirements.txt           # Python dependencies
├── .env.example              # Example environment variables
└── README.md                 # This file (you are here)
```
</details>

## 🚀 Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      • Python 3.11 or later<br>
      • Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      • Docker and Docker Compose (for containerized deployment)<br>
      • Polygon.io API key (for production-quality market data)<br>
      • Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      • Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### 💻 Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## 🏃‍♂️ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## 🔌 API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## 🔧 Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## 🔬 Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## 📚 Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### 📔 Guides Principaux

- **[🔍 Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrée central avec tous les guides disponibles
- **[📈 Guide de Day Trading](./docs/day_trading_guide.md)**: Système automatisé de day trading sur actions et crypto
- **[📊 Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[🧠 Guide d'Entraînement des Modèles](./docs/model_training_guide.md)**: Créer et entraîner des modèles d'IA

### 📖 Documentation Générale

- **[📚 Pour les Débutants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour débutants
- **[🔰 Guides Débutants](./docs/guides/beginner/)**: Ressources pour démarrer rapidement
- **[🔧 Guides Avancés](./docs/guides/advanced/)**: Sujets spécialisés pour traders expérimentés
- **[📝 Documentation Référence](./docs/reference/)**: Détails techniques et spécifications API

## 🧪 Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## 🤝 Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## 📄 License

This project is open-source and available under the MIT License.

## 🌟 Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## 🙏 Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisé pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durée de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    Système de daytrading crypto utilisant directement l'API Alpaca
    
    Caractéristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - Stratégie simple de croisement de moyennes mobiles
    - Plusieurs durées de session (1h, 4h, 8h, nuit)
    - Paramètres de trading configurables
    - Journalisation complète et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le système de trading crypto"""
        self.session_duration = session_duration
        
        # Déterminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("Configuré pour le trading LIVE (réel)")
        else:  # mode paper par défaut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("Configuré pour le trading PAPER (simulation)")
            
        # URL des données de marché
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # Paramètres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisée de symboles à utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrée
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'état
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisé")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # Vérifier que le client est correctement initialisé
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connecté: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # Vérifier la disponibilité du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"Trouvé {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisée et vérifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisée de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisé n'est tradable")
                    
                # Vérifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de récupérer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de récupérer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """Démarrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"Démarrage de la session de trading crypto à {self.session_start_time}")
        logger.info(f"La session se terminera à {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Échec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # Démarrer la boucle de trading
        self.trading_loop()
        
        # Générer un rapport de performance à la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # Déterminer les symboles à trader pour cette itération
                # Limiter aux 10 premières cryptos pour éviter les limites de taux si pas de liste personnalisée
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre à jour l'état du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itération
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminée")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les données historiques (intervalles de 5 minutes pour les dernières 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaîne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de données historiques disponibles pour {symbol}")
                return
            
            # Si les données sont multi-index (symbole, timestamp), prendre juste le symbole concerné
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la dernière barre des dernières 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (dernière barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de données disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # Vérifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # Vérifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # Exécuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # Vérifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """Exécuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Arrondir la quantité à 6 décimales
            qty = round(qty, 6)
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """Exécuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"Quantité de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre à jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre à jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de récupération des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise à jour de l'état du portefeuille: {e}")
    
    def generate_performance_report(self):
        """Générer un rapport de performance à la fin de la session de trading"""
        # Créer un fichier de rapport séparé
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"Durée de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de début: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'état final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes à la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes à la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÉE")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de génération du rapport de performance: {e}")

        # Écrire le rapport également dans un fichier séparé
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"Durée de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de début: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de récupérer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes à la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de récupérer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÉSUMÉ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuée\n")
                
        logger.info(f"Rapport détaillé sauvegardé dans {report_file}")

def main():
    """Point d'entrée principal"""
    parser = argparse.ArgumentParser(description="Système de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="Durée de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="Durée personnalisée en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # Définir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # Déterminer la durée de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # Créer le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reçu, arrêt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Exécuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reçue, arrêt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exécution du trader crypto: {e}")
    finally:
        logger.info("Arrêt du trader crypto terminé")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

Vérifie spécifiquement les fonctionnalités premium de votre abonnement Alpaca à 100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api importé avec succès")
except ImportError:
    logger.error("❌ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api installé et importé avec succès")

def test_premium_features():
    """Teste les fonctionnalités spécifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester à la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # Récupérer les informations d'authentification appropriées
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"✅ Connecté à l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"✅ Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de déterminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"✅ Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("ℹ️ Impossible de déterminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des informations du compte: {e}")
            
            # 2. Test des données de marché historiques (journalières)
            logger.info("\n----- TEST DES DONNÉES DE MARCHÉ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test données journalières sur 5 jours (devrait fonctionner même sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données journalières pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"✅ {len(daily_bars)} barres journalières récupérées")
                    logger.info(f"   Dernier prix de clôture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"⚠️ Aucune donnée journalière récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données journalières: {e}")
            
            # 2.2 Test données minutes (souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données minutes pour {symbol} des dernières 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"✅ {len(minute_bars)} barres minutes récupérées")
                    logger.info(f"   Première barre: {minute_bars[0].t}")
                    logger.info(f"   Dernière barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"⚠️ Aucune donnée minute récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données minutes: {e}")
            
            # 2.3 Test historique étendu (2+ ans, souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération de l'historique étendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"✅ {len(long_bars)} barres d'historique étendu récupérées")
                        logger.info(f"   Couvrant {days_of_data} jours de données")
                    else:
                        logger.warning(f"⚠️ Historique limité à {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"⚠️ Aucune donnée d'historique étendu récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération de l'historique étendu: {e}")
            
            # 2.4 Test données pour plusieurs symboles simultanément
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"✅ Données récupérées pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("⚠️ Aucune donnée récupérée pour les multiples symboles")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données multi-symboles: {e}")
            
            # 3. Test des données de news (souvent limité aux abonnements premium)
            logger.info("\n----- TEST DES DONNÉES DE NEWS -----")
            try:
                logger.info(f"Récupération des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"✅ {len(news)} articles de news récupérés")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"⚠️ Aucune news récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des news: {e}")
            
            # Résumé des tests
            logger.info("\n----- RÉSUMÉ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"✅ Connexion au mode {mode.upper()}: Réussie")
            else:
                logger.error(f"❌ Connexion au mode {mode.upper()}: Échec")
                
            if results[mode]["account_info"]:
                logger.info(f"✅ Informations du compte: Disponibles")
            else:
                logger.error(f"❌ Informations du compte: Non disponibles")
            
            logger.info(f"Données de marché:")
            for data_type, success in results[mode]["market_data"].items():
                status = "✅ Disponible" if success else "❌ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "✅ Disponible" if results[mode]["news_data"] else "❌ Non disponible"
            logger.info(f"Données de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("🌟 Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("⭐ Votre compte semble avoir certaines fonctionnalités premium.")
            else:
                logger.warning("⚠️ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"❌ Erreur générale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\n🚀 DÉMARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vérifier si votre abonnement Alpaca à 100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\n🏁 TEST TERMINÉ")
    logger.info("Récapitulatif des fonctionnalités premium détectées:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "🌟 PREMIUM"
        elif premium_count >= 1:
            status = "⭐ PARTIEL"
        else:
            status = "❌ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalités premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalités premium, vérifiez que:")
    logger.info("1. Votre abonnement est bien activé sur le compte Alpaca")
    logger.info("2. Les clés API utilisées correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalités testées")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"✅ Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("❌ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"✅ Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("❌ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"❌ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"✅ Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("❌ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"❌ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"✅ Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"❌ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("✅ All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("❌ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vérification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalités spécifiques à l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vérifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("Clés API Alpaca non définies dans le fichier .env")
        return
        
    logger.info(f"Connexion à Alpaca avec la clé: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. Vérifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de récupérer les détails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de récupérer la configuration du compte: {e}")
        
        # 2. Vérifier l'accès aux données de marché
        # Symboles à tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÉES EN TEMPS RÉEL ====")
        
        # 2.1 Vérifier les données en temps réel
        try:
            logger.info(f"Récupération du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # Vérifier si l'horodatage est récent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"Délai des données: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("✅ DONNÉES EN TEMPS RÉEL CONFIRMÉES")
            else:
                logger.warning("⚠️ Les données semblent être retardées")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÉES HISTORIQUES PREMIUM ====")
        
        # 2.2 Vérifier l'accès aux données historiques étendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"✅ {len(bars)} jours de données historiques récupérées")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la période couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"Période couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("✅ HISTORIQUE ÉTENDU PREMIUM CONFIRMÉ")
                else:
                    logger.warning("⚠️ Historique limité, peut-être pas d'accès premium complet")
            else:
                logger.warning("Aucune donnée historique récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données historiques: {e}")
        
        # 2.3 Vérifier l'accès aux données à haute résolution
        logger.info("\n==== TEST DES DONNÉES À HAUTE RÉSOLUTION ====")
        try:
            # Test des données minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"✅ {len(minute_bars)} barres de données minutes récupérées")
                logger.info("✅ DONNÉES À HAUTE RÉSOLUTION CONFIRMÉES")
            else:
                logger.warning("Aucune donnée minute récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données minutes: {e}")
        
        # 2.4 Vérifier l'accès aux données de plusieurs symboles
        logger.info("\n==== TEST DES DONNÉES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"✅ Données récupérées pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("✅ DONNÉES MULTI-SYMBOLES CONFIRMÉES")
            else:
                logger.warning("Aucune donnée multi-symboles récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données multi-symboles: {e}")
        
        # 3. Vérifier l'accès aux données fondamentales
        logger.info("\n==== TEST DES DONNÉES FONDAMENTALES ====")
        try:
            logger.info(f"Récupération des données fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"✅ {len(news)} articles de news récupérés")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("✅ DONNÉES DE NEWS CONFIRMÉES")
            else:
                logger.warning("Aucune donnée de news récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données fondamentales: {e}")
        
        # 4. Résumé des résultats
        logger.info("\n==== RÉSUMÉ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a été testé pour les fonctionnalités suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. Données en temps réel")
        logger.info("3. Historique étendu (2+ ans)")
        logger.info("4. Données à haute résolution (minutes)")
        logger.info("5. Données multi-symboles")
        logger.info("6. Données fondamentales/news")
        
        logger.info("\nCes fonctionnalités sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configuré pour utiliser ces fonctionnalités premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÉRIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")



================================================
FILE: custom_strategy_lstm_params.json
================================================
{
  "strategy_type": "lstm",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "lstm_units": 50,
    "dropout_rate": 0.2,
    "epochs": 50,
    "batch_size": 32,
    "use_gpu": true,
    "retrain": true,
    "position_size": 0.03,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_mean_reversion_params.json
================================================
{
  "strategy_type": "mean_reversion",
  "params": {
    "lookback_period": 20,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_transformer_params.json
================================================
{
  "strategy_type": "transformer",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "d_model": 64,
    "nhead": 4,
    "num_layers": 2,
    "dropout": 0.1,
    "signal_threshold": 0.6,
    "use_gpu": false,
    "retrain": false,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: data_generator.py
================================================
"""
Mercurio AI - Data Generator

This module generates realistic market data for January 2025
to be used with the trading strategy simulations.
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os

def generate_market_data(symbol, start_date, end_date, initial_price=None, volatility=None):
    """
    Generate realistic OHLCV market data for a symbol.
    
    Args:
        symbol: The market symbol (e.g., 'AAPL', 'BTC-USD')
        start_date: Start date for generated data
        end_date: End date for generated data
        initial_price: Starting price (if None, uses a realistic default)
        volatility: Price volatility (if None, uses realistic default based on symbol)
    
    Returns:
        DataFrame with columns: date, open, high, low, close, volume
    """
    # Set realistic initial prices and volatility if not provided
    if initial_price is None:
        price_defaults = {
            'AAPL': 190.0, 'MSFT': 410.0, 'GOOGL': 160.0, 'AMZN': 180.0, 'TSLA': 175.0,
            'BTC-USD': 42000.0, 'ETH-USD': 2200.0, 'SOL-USD': 95.0, 'ADA-USD': 0.45, 'DOT-USD': 7.0
        }
        initial_price = price_defaults.get(symbol, 100.0)
    
    if volatility is None:
        # Higher volatility for crypto
        if '-USD' in symbol:
            volatility = 0.025  # 2.5% daily volatility for crypto
        else:
            volatility = 0.015  # 1.5% daily volatility for stocks
    
    # Generate date range (exclude weekends for stocks)
    date_range = []
    current_date = start_date
    is_crypto = '-USD' in symbol
    
    while current_date <= end_date:
        # For stocks, skip weekends
        if is_crypto or current_date.weekday() < 5:  # 0-4 are Monday to Friday
            date_range.append(current_date)
        current_date += timedelta(days=1)
    
    # Ensure at least 3 rows of data for simulation
    min_rows = 3
    if len(date_range) < min_rows:
        # Extend backwards in time if needed
        print(f"[WARNING] Not enough data points for {symbol} between {start_date} and {end_date}. Auto-extending date range to ensure at least {min_rows} data points.")
        needed = min_rows - len(date_range)
        ext_date = (date_range[0] if date_range else end_date)
        ext_dates = []
        while len(ext_dates) < needed:
            ext_date = ext_date - timedelta(days=1)
            if is_crypto or ext_date.weekday() < 5:
                ext_dates.insert(0, ext_date)
        date_range = ext_dates + date_range
    
    # Generate price data using geometric Brownian motion
    n_days = len(date_range)
    returns = np.random.normal(0, volatility, n_days)
    
    # Add a slight drift (upward bias for January 2025)
    drift = 0.001  # 0.1% daily drift
    returns = returns + drift
    
    # Calculate price series
    prices = [initial_price]
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    # Generate realistic OHLCV data
    data = []
    for i, date in enumerate(date_range):
        close_price = prices[i]
        high_low_range = close_price * volatility * 1.5
        
        # Ensure first day price matches initial_price for the close
        if i == 0:
            close_price = initial_price
            
        open_price = prices[i-1] if i > 0 else close_price * (1 - volatility/2)
        high_price = max(open_price, close_price) + np.random.uniform(0, high_low_range)
        low_price = min(open_price, close_price) - np.random.uniform(0, high_low_range)
        
        # Generate volume (higher for more volatile days)
        price_change = abs(close_price - open_price)
        base_volume = close_price * 1000  # Base volume proportional to price
        volume = int(base_volume * (1 + 5 * price_change / close_price))
        
        data.append({
            'date': date,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume
        })
    
    df = pd.DataFrame(data)
    df.set_index('date', inplace=True)
    
    return df

def save_market_data(symbol, data, directory='data'):
    """Save market data to CSV file."""
    os.makedirs(directory, exist_ok=True)
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    data.to_csv(filename)
    print(f"Saved data for {symbol} to {filename}")
    return filename

def generate_all_market_data(symbols, start_date, end_date, directory='data'):
    MIN_ROWS = 10
    for symbol in symbols:
        print(f"Generating data for {symbol}...")
        data = generate_market_data(symbol, start_date, end_date)
        tries = 0
        while (data is None or len(data) < MIN_ROWS) and tries < 5:
            start_date = start_date - timedelta(days=5)
            data = generate_market_data(symbol, start_date, end_date)
            tries += 1
        if data is not None and len(data) >= MIN_ROWS:
            filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
            data.to_csv(filename)
            print(f"Saved data for {symbol} to {filename}")
        else:
            print(f"Failed to generate sufficient data for {symbol} (rows: {len(data) if data is not None else 0})")

def load_market_data(symbol, directory='data'):
    """Load market data from CSV file."""
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    if os.path.exists(filename):
        data = pd.read_csv(filename)
        data['date'] = pd.to_datetime(data['date'])
        data.set_index('date', inplace=True)
        return data
    else:
        return None

if __name__ == "__main__":
    # Test the data generator
    symbols = ['AAPL', 'MSFT', 'GOOGL', 'BTC-USD', 'ETH-USD']
    start_date = datetime(2025, 1, 1)
    end_date = datetime(2025, 1, 31)
    
    files = generate_all_market_data(symbols, start_date, end_date)
    print(f"Generated data files: {files}")
    
    # Load and display sample data
    aapl_data = load_market_data('AAPL')
    if aapl_data is not None:
        print("\nSample AAPL data:")
        print(aapl_data.head())



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  worker:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app worker --loglevel=info

  beat:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app beat --loglevel=info

  flower:
    build: .
    ports:
      - "5555:5555"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app flower

  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=mercurio

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:



================================================
FILE: Dockerfile
================================================
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create directories
RUN mkdir -p ./logs ./data ./models

# Expose port
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]



================================================
FILE: lingest
================================================
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>🚀 Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## 💼 Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### 🌟 Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## 📂 Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
├── app/                       # Core application directory
│   ├── main.py                # FastAPI application entry point
│   ├── api/                   # API endpoints
│   │   ├── routes.py          # API route definitions
│   │   └── schemas.py         # Pydantic models for requests/responses
│   ├── services/              # Business logic services
│   │   ├── market_data.py     # Service for fetching market data
│   │   ├── trading.py         # Service for executing trades
│   │   └── backtesting.py     # Service for backtesting strategies
│   ├── strategies/            # Trading strategies
│   │   ├── base.py            # Base strategy class
│   │   ├── moving_average.py  # Moving Average Crossover strategy
│   │   ├── lstm_predictor.py  # LSTM-based prediction strategy
│   │   ├── transformer.py     # Transformer-based strategy
│   │   ├── llm_strategy.py    # LLM-powered strategy
│   │   └── msi_strategy.py    # Market Sentiment Index strategy
│   ├── db/                    # Database modules
│   │   ├── database.py        # Database connection
│   │   └── models.py          # SQLAlchemy models
│   ├── tasks/                 # Celery tasks
│   │   ├── celery_app.py      # Celery configuration
│   │   ├── training.py        # Tasks for model training
│   │   ├── trading.py         # Tasks for automated trading
│   │   └── data.py            # Tasks for data collection
│   └── utils/                 # Utility functions
├── docs/                      # Documentation directory
│   ├── for-dummies/           # Comprehensive guide for beginners
│   ├── guides/                # Specialized guides
│   │   ├── beginner/          # Beginner guides
│   │   └── advanced/          # Advanced guides
│   ├── api/                   # API documentation
│   ├── reference/             # Technical reference
│   └── README.md              # Documentation index
├── models/                    # Saved ML models
│   ├── lstm/                  # LSTM models and scalers
│   └── transformer/           # Transformer models and scalers
├── data/                      # Data directory
│   └── sample_data/           # Sample data for testing
├── reports/                   # Reports and visualizations
│   ├── comprehensive/         # Comprehensive simulation results
│   └── visualizations/        # Generated charts and graphs
├── tests/                     # Tests directory
├── comprehensive_simulation.py # Full-featured simulation script
├── strategy_dashboard.py      # Streamlit dashboard for strategy visualization
├── docker-compose.yml         # Docker Compose configuration
├── Dockerfile                 # Docker configuration
├── requirements.txt           # Python dependencies
├── .env.example              # Example environment variables
└── README.md                 # This file (you are here)
```
</details>

## 🚀 Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      • Python 3.11 or later<br>
      • Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      • Docker and Docker Compose (for containerized deployment)<br>
      • Polygon.io API key (for production-quality market data)<br>
      • Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      • Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### 💻 Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## 🏃‍♂️ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## 🔌 API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## 🔧 Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## 🔬 Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## 📚 Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### 📔 Guides Principaux

- **[🔍 Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrée central avec tous les guides disponibles
- **[📈 Guide de Day Trading](./docs/day_trading_guide.md)**: Système automatisé de day trading sur actions et crypto
- **[📊 Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[🧠 Guide d'Entraînement des Modèles](./docs/model_training_guide.md)**: Créer et entraîner des modèles d'IA

### 📖 Documentation Générale

- **[📚 Pour les Débutants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour débutants
- **[🔰 Guides Débutants](./docs/guides/beginner/)**: Ressources pour démarrer rapidement
- **[🔧 Guides Avancés](./docs/guides/advanced/)**: Sujets spécialisés pour traders expérimentés
- **[📝 Documentation Référence](./docs/reference/)**: Détails techniques et spécifications API

## 🧪 Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## 🤝 Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## 📄 License

This project is open-source and available under the MIT License.

## 🌟 Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## 🙏 Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisé pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durée de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    Système de daytrading crypto utilisant directement l'API Alpaca
    
    Caractéristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - Stratégie simple de croisement de moyennes mobiles
    - Plusieurs durées de session (1h, 4h, 8h, nuit)
    - Paramètres de trading configurables
    - Journalisation complète et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le système de trading crypto"""
        self.session_duration = session_duration
        
        # Déterminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("Configuré pour le trading LIVE (réel)")
        else:  # mode paper par défaut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("Configuré pour le trading PAPER (simulation)")
            
        # URL des données de marché
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # Paramètres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisée de symboles à utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrée
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'état
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisé")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # Vérifier que le client est correctement initialisé
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connecté: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # Vérifier la disponibilité du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"Trouvé {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisée et vérifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisée de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisé n'est tradable")
                    
                # Vérifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de récupérer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de récupérer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """Démarrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"Démarrage de la session de trading crypto à {self.session_start_time}")
        logger.info(f"La session se terminera à {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Échec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # Démarrer la boucle de trading
        self.trading_loop()
        
        # Générer un rapport de performance à la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # Déterminer les symboles à trader pour cette itération
                # Limiter aux 10 premières cryptos pour éviter les limites de taux si pas de liste personnalisée
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre à jour l'état du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itération
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminée")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les données historiques (intervalles de 5 minutes pour les dernières 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaîne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de données historiques disponibles pour {symbol}")
                return
            
            # Si les données sont multi-index (symbole, timestamp), prendre juste le symbole concerné
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la dernière barre des dernières 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (dernière barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de données disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # Vérifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # Vérifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # Exécuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # Vérifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """Exécuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Arrondir la quantité à 6 décimales
            qty = round(qty, 6)
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """Exécuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"Quantité de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre à jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre à jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de récupération des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise à jour de l'état du portefeuille: {e}")
    
    def generate_performance_report(self):
        """Générer un rapport de performance à la fin de la session de trading"""
        # Créer un fichier de rapport séparé
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"Durée de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de début: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'état final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes à la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes à la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÉE")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de génération du rapport de performance: {e}")

        # Écrire le rapport également dans un fichier séparé
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"Durée de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de début: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de récupérer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes à la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de récupérer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÉSUMÉ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuée\n")
                
        logger.info(f"Rapport détaillé sauvegardé dans {report_file}")

def main():
    """Point d'entrée principal"""
    parser = argparse.ArgumentParser(description="Système de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="Durée de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="Durée personnalisée en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # Définir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # Déterminer la durée de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # Créer le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reçu, arrêt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Exécuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reçue, arrêt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exécution du trader crypto: {e}")
    finally:
        logger.info("Arrêt du trader crypto terminé")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

Vérifie spécifiquement les fonctionnalités premium de votre abonnement Alpaca à 100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api importé avec succès")
except ImportError:
    logger.error("❌ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api installé et importé avec succès")

def test_premium_features():
    """Teste les fonctionnalités spécifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester à la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # Récupérer les informations d'authentification appropriées
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"✅ Connecté à l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"✅ Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de déterminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"✅ Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("ℹ️ Impossible de déterminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des informations du compte: {e}")
            
            # 2. Test des données de marché historiques (journalières)
            logger.info("\n----- TEST DES DONNÉES DE MARCHÉ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test données journalières sur 5 jours (devrait fonctionner même sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données journalières pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"✅ {len(daily_bars)} barres journalières récupérées")
                    logger.info(f"   Dernier prix de clôture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"⚠️ Aucune donnée journalière récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données journalières: {e}")
            
            # 2.2 Test données minutes (souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données minutes pour {symbol} des dernières 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"✅ {len(minute_bars)} barres minutes récupérées")
                    logger.info(f"   Première barre: {minute_bars[0].t}")
                    logger.info(f"   Dernière barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"⚠️ Aucune donnée minute récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données minutes: {e}")
            
            # 2.3 Test historique étendu (2+ ans, souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération de l'historique étendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"✅ {len(long_bars)} barres d'historique étendu récupérées")
                        logger.info(f"   Couvrant {days_of_data} jours de données")
                    else:
                        logger.warning(f"⚠️ Historique limité à {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"⚠️ Aucune donnée d'historique étendu récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération de l'historique étendu: {e}")
            
            # 2.4 Test données pour plusieurs symboles simultanément
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"✅ Données récupérées pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("⚠️ Aucune donnée récupérée pour les multiples symboles")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données multi-symboles: {e}")
            
            # 3. Test des données de news (souvent limité aux abonnements premium)
            logger.info("\n----- TEST DES DONNÉES DE NEWS -----")
            try:
                logger.info(f"Récupération des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"✅ {len(news)} articles de news récupérés")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"⚠️ Aucune news récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des news: {e}")
            
            # Résumé des tests
            logger.info("\n----- RÉSUMÉ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"✅ Connexion au mode {mode.upper()}: Réussie")
            else:
                logger.error(f"❌ Connexion au mode {mode.upper()}: Échec")
                
            if results[mode]["account_info"]:
                logger.info(f"✅ Informations du compte: Disponibles")
            else:
                logger.error(f"❌ Informations du compte: Non disponibles")
            
            logger.info(f"Données de marché:")
            for data_type, success in results[mode]["market_data"].items():
                status = "✅ Disponible" if success else "❌ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "✅ Disponible" if results[mode]["news_data"] else "❌ Non disponible"
            logger.info(f"Données de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("🌟 Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("⭐ Votre compte semble avoir certaines fonctionnalités premium.")
            else:
                logger.warning("⚠️ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"❌ Erreur générale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\n🚀 DÉMARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vérifier si votre abonnement Alpaca à 100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\n🏁 TEST TERMINÉ")
    logger.info("Récapitulatif des fonctionnalités premium détectées:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "🌟 PREMIUM"
        elif premium_count >= 1:
            status = "⭐ PARTIEL"
        else:
            status = "❌ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalités premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalités premium, vérifiez que:")
    logger.info("1. Votre abonnement est bien activé sur le compte Alpaca")
    logger.info("2. Les clés API utilisées correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalités testées")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"✅ Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("❌ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"✅ Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("❌ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"❌ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"✅ Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("❌ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"❌ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"✅ Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"❌ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("✅ All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("❌ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vérification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalités spécifiques à l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vérifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("Clés API Alpaca non définies dans le fichier .env")
        return
        
    logger.info(f"Connexion à Alpaca avec la clé: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. Vérifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de récupérer les détails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de récupérer la configuration du compte: {e}")
        
        # 2. Vérifier l'accès aux données de marché
        # Symboles à tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÉES EN TEMPS RÉEL ====")
        
        # 2.1 Vérifier les données en temps réel
        try:
            logger.info(f"Récupération du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # Vérifier si l'horodatage est récent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"Délai des données: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("✅ DONNÉES EN TEMPS RÉEL CONFIRMÉES")
            else:
                logger.warning("⚠️ Les données semblent être retardées")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÉES HISTORIQUES PREMIUM ====")
        
        # 2.2 Vérifier l'accès aux données historiques étendues
        try:
            # Test sur 2 ans
            end = datetime.now()