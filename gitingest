(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>🚀 Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## 💼 Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### 🌟 Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## 📂 Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
├── app/                       # Core application directory
│   ├── main.py                # FastAPI application entry point
│   ├── api/                   # API endpoints
│   │   ├── routes.py          # API route definitions
│   │   └── schemas.py         # Pydantic models for requests/responses
│   ├── services/              # Business logic services
│   │   ├── market_data.py     # Service for fetching market data
│   │   ├── trading.py         # Service for executing trades
│   │   └── backtesting.py     # Service for backtesting strategies
│   ├── strategies/            # Trading strategies
│   │   ├── base.py            # Base strategy class
│   │   ├── moving_average.py  # Moving Average Crossover strategy
│   │   ├── lstm_predictor.py  # LSTM-based prediction strategy
│   │   ├── transformer.py     # Transformer-based strategy
│   │   ├── llm_strategy.py    # LLM-powered strategy
│   │   └── msi_strategy.py    # Market Sentiment Index strategy
│   ├── db/                    # Database modules
│   │   ├── database.py        # Database connection
│   │   └── models.py          # SQLAlchemy models
│   ├── tasks/                 # Celery tasks
│   │   ├── celery_app.py      # Celery configuration
│   │   ├── training.py        # Tasks for model training
│   │   ├── trading.py         # Tasks for automated trading
│   │   └── data.py            # Tasks for data collection
│   └── utils/                 # Utility functions
├── docs/                      # Documentation directory
│   ├── for-dummies/           # Comprehensive guide for beginners
│   ├── guides/                # Specialized guides
│   │   ├── beginner/          # Beginner guides
│   │   └── advanced/          # Advanced guides
│   ├── api/                   # API documentation
│   ├── reference/             # Technical reference
│   └── README.md              # Documentation index
├── models/                    # Saved ML models
│   ├── lstm/                  # LSTM models and scalers
│   └── transformer/           # Transformer models and scalers
├── data/                      # Data directory
│   └── sample_data/           # Sample data for testing
├── reports/                   # Reports and visualizations
│   ├── comprehensive/         # Comprehensive simulation results
│   └── visualizations/        # Generated charts and graphs
├── tests/                     # Tests directory
├── comprehensive_simulation.py # Full-featured simulation script
├── strategy_dashboard.py      # Streamlit dashboard for strategy visualization
├── docker-compose.yml         # Docker Compose configuration
├── Dockerfile                 # Docker configuration
├── requirements.txt           # Python dependencies
├── .env.example              # Example environment variables
└── README.md                 # This file (you are here)
```
</details>

## 🚀 Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      • Python 3.11 or later<br>
      • Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      • Docker and Docker Compose (for containerized deployment)<br>
      • Polygon.io API key (for production-quality market data)<br>
      • Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      • Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### 💻 Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## 🏃‍♂️ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## 🔌 API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## 🔧 Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## 🔬 Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## 📚 Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### 📔 Guides Principaux

- **[🔍 Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrée central avec tous les guides disponibles
- **[📈 Guide de Day Trading](./docs/day_trading_guide.md)**: Système automatisé de day trading sur actions et crypto
- **[📊 Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[🧠 Guide d'Entraînement des Modèles](./docs/model_training_guide.md)**: Créer et entraîner des modèles d'IA

### 📖 Documentation Générale

- **[📚 Pour les Débutants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour débutants
- **[🔰 Guides Débutants](./docs/guides/beginner/)**: Ressources pour démarrer rapidement
- **[🔧 Guides Avancés](./docs/guides/advanced/)**: Sujets spécialisés pour traders expérimentés
- **[📝 Documentation Référence](./docs/reference/)**: Détails techniques et spécifications API

## 🧪 Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## 🤝 Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## 📄 License

This project is open-source and available under the MIT License.

## 🌟 Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## 🙏 Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisé pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durée de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    Système de daytrading crypto utilisant directement l'API Alpaca
    
    Caractéristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - Stratégie simple de croisement de moyennes mobiles
    - Plusieurs durées de session (1h, 4h, 8h, nuit)
    - Paramètres de trading configurables
    - Journalisation complète et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le système de trading crypto"""
        self.session_duration = session_duration
        
        # Déterminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("Configuré pour le trading LIVE (réel)")
        else:  # mode paper par défaut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("Configuré pour le trading PAPER (simulation)")
            
        # URL des données de marché
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # Paramètres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisée de symboles à utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrée
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'état
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisé")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # Vérifier que le client est correctement initialisé
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connecté: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # Vérifier la disponibilité du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"Trouvé {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisée et vérifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisée de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisé n'est tradable")
                    
                # Vérifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de récupérer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de récupérer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """Démarrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"Démarrage de la session de trading crypto à {self.session_start_time}")
        logger.info(f"La session se terminera à {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Échec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # Démarrer la boucle de trading
        self.trading_loop()
        
        # Générer un rapport de performance à la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # Déterminer les symboles à trader pour cette itération
                # Limiter aux 10 premières cryptos pour éviter les limites de taux si pas de liste personnalisée
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre à jour l'état du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itération
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminée")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les données historiques (intervalles de 5 minutes pour les dernières 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaîne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de données historiques disponibles pour {symbol}")
                return
            
            # Si les données sont multi-index (symbole, timestamp), prendre juste le symbole concerné
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la dernière barre des dernières 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (dernière barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de données disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # Vérifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # Vérifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # Exécuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # Vérifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """Exécuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Arrondir la quantité à 6 décimales
            qty = round(qty, 6)
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """Exécuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"Quantité de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre à jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre à jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de récupération des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise à jour de l'état du portefeuille: {e}")
    
    def generate_performance_report(self):
        """Générer un rapport de performance à la fin de la session de trading"""
        # Créer un fichier de rapport séparé
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"Durée de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de début: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'état final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes à la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes à la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÉE")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de génération du rapport de performance: {e}")

        # Écrire le rapport également dans un fichier séparé
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"Durée de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de début: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de récupérer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes à la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de récupérer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÉSUMÉ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuée\n")
                
        logger.info(f"Rapport détaillé sauvegardé dans {report_file}")

def main():
    """Point d'entrée principal"""
    parser = argparse.ArgumentParser(description="Système de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="Durée de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="Durée personnalisée en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # Définir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # Déterminer la durée de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # Créer le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reçu, arrêt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Exécuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reçue, arrêt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exécution du trader crypto: {e}")
    finally:
        logger.info("Arrêt du trader crypto terminé")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

Vérifie spécifiquement les fonctionnalités premium de votre abonnement Alpaca à 100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api importé avec succès")
except ImportError:
    logger.error("❌ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api installé et importé avec succès")

def test_premium_features():
    """Teste les fonctionnalités spécifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester à la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # Récupérer les informations d'authentification appropriées
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"✅ Connecté à l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"✅ Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de déterminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"✅ Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("ℹ️ Impossible de déterminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des informations du compte: {e}")
            
            # 2. Test des données de marché historiques (journalières)
            logger.info("\n----- TEST DES DONNÉES DE MARCHÉ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test données journalières sur 5 jours (devrait fonctionner même sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données journalières pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"✅ {len(daily_bars)} barres journalières récupérées")
                    logger.info(f"   Dernier prix de clôture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"⚠️ Aucune donnée journalière récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données journalières: {e}")
            
            # 2.2 Test données minutes (souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données minutes pour {symbol} des dernières 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"✅ {len(minute_bars)} barres minutes récupérées")
                    logger.info(f"   Première barre: {minute_bars[0].t}")
                    logger.info(f"   Dernière barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"⚠️ Aucune donnée minute récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données minutes: {e}")
            
            # 2.3 Test historique étendu (2+ ans, souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération de l'historique étendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"✅ {len(long_bars)} barres d'historique étendu récupérées")
                        logger.info(f"   Couvrant {days_of_data} jours de données")
                    else:
                        logger.warning(f"⚠️ Historique limité à {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"⚠️ Aucune donnée d'historique étendu récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération de l'historique étendu: {e}")
            
            # 2.4 Test données pour plusieurs symboles simultanément
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"✅ Données récupérées pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("⚠️ Aucune donnée récupérée pour les multiples symboles")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données multi-symboles: {e}")
            
            # 3. Test des données de news (souvent limité aux abonnements premium)
            logger.info("\n----- TEST DES DONNÉES DE NEWS -----")
            try:
                logger.info(f"Récupération des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"✅ {len(news)} articles de news récupérés")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"⚠️ Aucune news récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des news: {e}")
            
            # Résumé des tests
            logger.info("\n----- RÉSUMÉ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"✅ Connexion au mode {mode.upper()}: Réussie")
            else:
                logger.error(f"❌ Connexion au mode {mode.upper()}: Échec")
                
            if results[mode]["account_info"]:
                logger.info(f"✅ Informations du compte: Disponibles")
            else:
                logger.error(f"❌ Informations du compte: Non disponibles")
            
            logger.info(f"Données de marché:")
            for data_type, success in results[mode]["market_data"].items():
                status = "✅ Disponible" if success else "❌ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "✅ Disponible" if results[mode]["news_data"] else "❌ Non disponible"
            logger.info(f"Données de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("🌟 Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("⭐ Votre compte semble avoir certaines fonctionnalités premium.")
            else:
                logger.warning("⚠️ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"❌ Erreur générale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\n🚀 DÉMARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vérifier si votre abonnement Alpaca à 100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\n🏁 TEST TERMINÉ")
    logger.info("Récapitulatif des fonctionnalités premium détectées:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "🌟 PREMIUM"
        elif premium_count >= 1:
            status = "⭐ PARTIEL"
        else:
            status = "❌ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalités premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalités premium, vérifiez que:")
    logger.info("1. Votre abonnement est bien activé sur le compte Alpaca")
    logger.info("2. Les clés API utilisées correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalités testées")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"✅ Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("❌ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"✅ Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("❌ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"❌ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"✅ Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("❌ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"❌ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"✅ Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"❌ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("✅ All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("❌ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vérification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalités spécifiques à l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vérifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("Clés API Alpaca non définies dans le fichier .env")
        return
        
    logger.info(f"Connexion à Alpaca avec la clé: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. Vérifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de récupérer les détails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de récupérer la configuration du compte: {e}")
        
        # 2. Vérifier l'accès aux données de marché
        # Symboles à tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÉES EN TEMPS RÉEL ====")
        
        # 2.1 Vérifier les données en temps réel
        try:
            logger.info(f"Récupération du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # Vérifier si l'horodatage est récent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"Délai des données: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("✅ DONNÉES EN TEMPS RÉEL CONFIRMÉES")
            else:
                logger.warning("⚠️ Les données semblent être retardées")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÉES HISTORIQUES PREMIUM ====")
        
        # 2.2 Vérifier l'accès aux données historiques étendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"✅ {len(bars)} jours de données historiques récupérées")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la période couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"Période couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("✅ HISTORIQUE ÉTENDU PREMIUM CONFIRMÉ")
                else:
                    logger.warning("⚠️ Historique limité, peut-être pas d'accès premium complet")
            else:
                logger.warning("Aucune donnée historique récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données historiques: {e}")
        
        # 2.3 Vérifier l'accès aux données à haute résolution
        logger.info("\n==== TEST DES DONNÉES À HAUTE RÉSOLUTION ====")
        try:
            # Test des données minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"✅ {len(minute_bars)} barres de données minutes récupérées")
                logger.info("✅ DONNÉES À HAUTE RÉSOLUTION CONFIRMÉES")
            else:
                logger.warning("Aucune donnée minute récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données minutes: {e}")
        
        # 2.4 Vérifier l'accès aux données de plusieurs symboles
        logger.info("\n==== TEST DES DONNÉES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"✅ Données récupérées pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("✅ DONNÉES MULTI-SYMBOLES CONFIRMÉES")
            else:
                logger.warning("Aucune donnée multi-symboles récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données multi-symboles: {e}")
        
        # 3. Vérifier l'accès aux données fondamentales
        logger.info("\n==== TEST DES DONNÉES FONDAMENTALES ====")
        try:
            logger.info(f"Récupération des données fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"✅ {len(news)} articles de news récupérés")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("✅ DONNÉES DE NEWS CONFIRMÉES")
            else:
                logger.warning("Aucune donnée de news récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données fondamentales: {e}")
        
        # 4. Résumé des résultats
        logger.info("\n==== RÉSUMÉ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a été testé pour les fonctionnalités suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. Données en temps réel")
        logger.info("3. Historique étendu (2+ ans)")
        logger.info("4. Données à haute résolution (minutes)")
        logger.info("5. Données multi-symboles")
        logger.info("6. Données fondamentales/news")
        
        logger.info("\nCes fonctionnalités sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configuré pour utiliser ces fonctionnalités premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÉRIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")



================================================
FILE: custom_strategy_lstm_params.json
================================================
{
  "strategy_type": "lstm",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "lstm_units": 50,
    "dropout_rate": 0.2,
    "epochs": 50,
    "batch_size": 32,
    "use_gpu": true,
    "retrain": true,
    "position_size": 0.03,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_mean_reversion_params.json
================================================
{
  "strategy_type": "mean_reversion",
  "params": {
    "lookback_period": 20,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: custom_strategy_transformer_params.json
================================================
{
  "strategy_type": "transformer",
  "params": {
    "sequence_length": 60,
    "prediction_horizon": 1,
    "d_model": 64,
    "nhead": 4,
    "num_layers": 2,
    "dropout": 0.1,
    "signal_threshold": 0.6,
    "use_gpu": false,
    "retrain": false,
    "position_size": 0.01,
    "stop_loss": 0.03,
    "take_profit": 0.06
  },
  "symbols": [
    "AAVE/USD",
    "AAVE/USDT",
    "AVAX/USD",
    "BAT/USD",
    "BCH/USD",
    "BCH/USDT",
    "BTC/USD",
    "BTC/USDT",
    "CRV/USD",
    "DOGE/USD",
    "DOGE/USDT",
    "DOT/USD",
    "ETH/USD",
    "ETH/USDT",
    "GRT/USD",
    "LINK/USD",
    "LINK/USDT",
    "LTC/USD",
    "LTC/USDT",
    "MKR/USD",
    "PEPE/USD",
    "SHIB/USD",
    "SOL/USD",
    "SUSHI/USD",
    "SUSHI/USDT",
    "TRUMP/USD",
    "UNI/USD",
    "UNI/USDT",
    "USDC/USD",
    "USDT/USD",
    "XRP/USD",
    "XTZ/USD",
    "YFI/USD",
    "YFI/USDT"
  ]
}


================================================
FILE: data_generator.py
================================================
"""
Mercurio AI - Data Generator

This module generates realistic market data for January 2025
to be used with the trading strategy simulations.
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os

def generate_market_data(symbol, start_date, end_date, initial_price=None, volatility=None):
    """
    Generate realistic OHLCV market data for a symbol.
    
    Args:
        symbol: The market symbol (e.g., 'AAPL', 'BTC-USD')
        start_date: Start date for generated data
        end_date: End date for generated data
        initial_price: Starting price (if None, uses a realistic default)
        volatility: Price volatility (if None, uses realistic default based on symbol)
    
    Returns:
        DataFrame with columns: date, open, high, low, close, volume
    """
    # Set realistic initial prices and volatility if not provided
    if initial_price is None:
        price_defaults = {
            'AAPL': 190.0, 'MSFT': 410.0, 'GOOGL': 160.0, 'AMZN': 180.0, 'TSLA': 175.0,
            'BTC-USD': 42000.0, 'ETH-USD': 2200.0, 'SOL-USD': 95.0, 'ADA-USD': 0.45, 'DOT-USD': 7.0
        }
        initial_price = price_defaults.get(symbol, 100.0)
    
    if volatility is None:
        # Higher volatility for crypto
        if '-USD' in symbol:
            volatility = 0.025  # 2.5% daily volatility for crypto
        else:
            volatility = 0.015  # 1.5% daily volatility for stocks
    
    # Generate date range (exclude weekends for stocks)
    date_range = []
    current_date = start_date
    is_crypto = '-USD' in symbol
    
    while current_date <= end_date:
        # For stocks, skip weekends
        if is_crypto or current_date.weekday() < 5:  # 0-4 are Monday to Friday
            date_range.append(current_date)
        current_date += timedelta(days=1)
    
    # Ensure at least 3 rows of data for simulation
    min_rows = 3
    if len(date_range) < min_rows:
        # Extend backwards in time if needed
        print(f"[WARNING] Not enough data points for {symbol} between {start_date} and {end_date}. Auto-extending date range to ensure at least {min_rows} data points.")
        needed = min_rows - len(date_range)
        ext_date = (date_range[0] if date_range else end_date)
        ext_dates = []
        while len(ext_dates) < needed:
            ext_date = ext_date - timedelta(days=1)
            if is_crypto or ext_date.weekday() < 5:
                ext_dates.insert(0, ext_date)
        date_range = ext_dates + date_range
    
    # Generate price data using geometric Brownian motion
    n_days = len(date_range)
    returns = np.random.normal(0, volatility, n_days)
    
    # Add a slight drift (upward bias for January 2025)
    drift = 0.001  # 0.1% daily drift
    returns = returns + drift
    
    # Calculate price series
    prices = [initial_price]
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    # Generate realistic OHLCV data
    data = []
    for i, date in enumerate(date_range):
        close_price = prices[i]
        high_low_range = close_price * volatility * 1.5
        
        # Ensure first day price matches initial_price for the close
        if i == 0:
            close_price = initial_price
            
        open_price = prices[i-1] if i > 0 else close_price * (1 - volatility/2)
        high_price = max(open_price, close_price) + np.random.uniform(0, high_low_range)
        low_price = min(open_price, close_price) - np.random.uniform(0, high_low_range)
        
        # Generate volume (higher for more volatile days)
        price_change = abs(close_price - open_price)
        base_volume = close_price * 1000  # Base volume proportional to price
        volume = int(base_volume * (1 + 5 * price_change / close_price))
        
        data.append({
            'date': date,
            'open': open_price,
            'high': high_price,
            'low': low_price,
            'close': close_price,
            'volume': volume
        })
    
    df = pd.DataFrame(data)
    df.set_index('date', inplace=True)
    
    return df

def save_market_data(symbol, data, directory='data'):
    """Save market data to CSV file."""
    os.makedirs(directory, exist_ok=True)
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    data.to_csv(filename)
    print(f"Saved data for {symbol} to {filename}")
    return filename

def generate_all_market_data(symbols, start_date, end_date, directory='data'):
    MIN_ROWS = 10
    for symbol in symbols:
        print(f"Generating data for {symbol}...")
        data = generate_market_data(symbol, start_date, end_date)
        tries = 0
        while (data is None or len(data) < MIN_ROWS) and tries < 5:
            start_date = start_date - timedelta(days=5)
            data = generate_market_data(symbol, start_date, end_date)
            tries += 1
        if data is not None and len(data) >= MIN_ROWS:
            filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
            data.to_csv(filename)
            print(f"Saved data for {symbol} to {filename}")
        else:
            print(f"Failed to generate sufficient data for {symbol} (rows: {len(data) if data is not None else 0})")

def load_market_data(symbol, directory='data'):
    """Load market data from CSV file."""
    filename = os.path.join(directory, f"{symbol.replace('-', '_')}_data.csv")
    if os.path.exists(filename):
        data = pd.read_csv(filename)
        data['date'] = pd.to_datetime(data['date'])
        data.set_index('date', inplace=True)
        return data
    else:
        return None

if __name__ == "__main__":
    # Test the data generator
    symbols = ['AAPL', 'MSFT', 'GOOGL', 'BTC-USD', 'ETH-USD']
    start_date = datetime(2025, 1, 1)
    end_date = datetime(2025, 1, 31)
    
    files = generate_all_market_data(symbols, start_date, end_date)
    print(f"Generated data files: {files}")
    
    # Load and display sample data
    aapl_data = load_market_data('AAPL')
    if aapl_data is not None:
        print("\nSample AAPL data:")
        print(aapl_data.head())



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  worker:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app worker --loglevel=info

  beat:
    build: .
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app beat --loglevel=info

  flower:
    build: .
    ports:
      - "5555:5555"
    volumes:
      - ./:/app
    depends_on:
      - postgres
      - redis
    env_file:
      - .env
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/mercurio
      - REDIS_URL=redis://redis:6379/0
    command: celery -A app.tasks.celery_app flower

  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=mercurio

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:



================================================
FILE: Dockerfile
================================================
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create directories
RUN mkdir -p ./logs ./data ./models

# Expose port
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]



================================================
FILE: lingest
================================================
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">
  <h1>🚀 Mercurio Systems Trading Platform</h1>
  <p><strong>The intelligent, resilient algorithmic trading platform that adapts to any market condition</strong></p>
  <p>
    <a href="#installation"><img src="https://img.shields.io/badge/Installation-Guide-blue"/></a>
    <a href="#quick-start"><img src="https://img.shields.io/badge/Quick-Start-brightgreen"/></a>
    <a href="docs/for-dummies/01-introduction.md"><img src="https://img.shields.io/badge/Documentation-Complete-orange"/></a>
    <a href="https://mercurio.systems"><img src="https://img.shields.io/badge/Website-https%3A%2F%2Fmercurio.systems-blue"/></a>
    <a href="https://github.com/deepload/Mercurio"><img src="https://img.shields.io/badge/GitHub-https%3A%2F%2Fgithub.com%2Fdeepload%2FMercurio-blue"/></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow"/></a>
  </p>
</div>

## 💼 Overview

Mercurio is a comprehensive algorithmic trading platform built with reliability and versatility at its core. Whether you're a beginner exploring trading strategies or an expert deploying sophisticated machine learning models, Mercurio provides all the tools you need in one integrated ecosystem.

### 🌟 Key Features

- **Multiple Strategy Types**: From simple moving averages to advanced ML models (LSTM, Transformer, LLM)
- **Fallback Mechanisms**: Test and trade without API keys using our multi-layered fallback system
- **Paper Trading Mode**: Practice risk-free with simulated trading
- **Comprehensive Backtesting**: Evaluate strategies against historical data
- **Interactive Dashboards**: Monitor performance with Streamlit-powered visualizations
- **Asset Diversity**: Trade stocks and cryptocurrencies (BTC-USD, ETH-USD, etc.) across multiple timeframes
- **Resilient Architecture**: Ensures continuous operation even during outages

## 📂 Project Structure

<details>
<summary><strong>Click to expand project structure</strong></summary>

```
Mercurio/
├── app/                       # Core application directory
│   ├── main.py                # FastAPI application entry point
│   ├── api/                   # API endpoints
│   │   ├── routes.py          # API route definitions
│   │   └── schemas.py         # Pydantic models for requests/responses
│   ├── services/              # Business logic services
│   │   ├── market_data.py     # Service for fetching market data
│   │   ├── trading.py         # Service for executing trades
│   │   └── backtesting.py     # Service for backtesting strategies
│   ├── strategies/            # Trading strategies
│   │   ├── base.py            # Base strategy class
│   │   ├── moving_average.py  # Moving Average Crossover strategy
│   │   ├── lstm_predictor.py  # LSTM-based prediction strategy
│   │   ├── transformer.py     # Transformer-based strategy
│   │   ├── llm_strategy.py    # LLM-powered strategy
│   │   └── msi_strategy.py    # Market Sentiment Index strategy
│   ├── db/                    # Database modules
│   │   ├── database.py        # Database connection
│   │   └── models.py          # SQLAlchemy models
│   ├── tasks/                 # Celery tasks
│   │   ├── celery_app.py      # Celery configuration
│   │   ├── training.py        # Tasks for model training
│   │   ├── trading.py         # Tasks for automated trading
│   │   └── data.py            # Tasks for data collection
│   └── utils/                 # Utility functions
├── docs/                      # Documentation directory
│   ├── for-dummies/           # Comprehensive guide for beginners
│   ├── guides/                # Specialized guides
│   │   ├── beginner/          # Beginner guides
│   │   └── advanced/          # Advanced guides
│   ├── api/                   # API documentation
│   ├── reference/             # Technical reference
│   └── README.md              # Documentation index
├── models/                    # Saved ML models
│   ├── lstm/                  # LSTM models and scalers
│   └── transformer/           # Transformer models and scalers
├── data/                      # Data directory
│   └── sample_data/           # Sample data for testing
├── reports/                   # Reports and visualizations
│   ├── comprehensive/         # Comprehensive simulation results
│   └── visualizations/        # Generated charts and graphs
├── tests/                     # Tests directory
├── comprehensive_simulation.py # Full-featured simulation script
├── strategy_dashboard.py      # Streamlit dashboard for strategy visualization
├── docker-compose.yml         # Docker Compose configuration
├── Dockerfile                 # Docker configuration
├── requirements.txt           # Python dependencies
├── .env.example              # Example environment variables
└── README.md                 # This file (you are here)
```
</details>

## 🚀 Getting Started

### Prerequisites

<table>
  <tr>
    <td><strong>Required</strong></td>
    <td>
      • Python 3.11 or later<br>
      • Git
    </td>
  </tr>
  <tr>
    <td><strong>Optional</strong></td>
    <td>
      • Docker and Docker Compose (for containerized deployment)<br>
      • Polygon.io API key (for production-quality market data)<br>
      • Alpaca Paper Trading API keys (for risk-free paper trading)<br>
      • Alpaca Live Trading API keys (for real money trading)<br>
    </td>
  </tr>
  <tr>
    <td><strong>Note</strong></td>
    <td>Thanks to Mercurio's fallback system, no API keys are required to get started with testing and development!</td>
  </tr>
</table>

### 💻 Installation

<details open>
<summary><strong>Standard Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create and activate virtual environment
python -m venv venv
venv\Scripts\activate  # On Windows
# source venv/bin/activate  # On Unix/MacOS

# Install dependencies
pip install -r requirements.txt

# Set up environment variables (optional for testing)
copy .env.example .env
# Edit .env with your API keys if available
# For Alpaca, configure both paper and live trading modes:
```
</details>

<details>
<summary><strong>Docker Installation</strong></summary>

```bash
# Clone the repository
git clone https://github.com/deepload/Mercurio
cd mercurio-systems

# Create environment file
copy .env.example .env
# Edit .env with your configuration

# Start the services
docker-compose up -d
```

The following services will be available:
- API: http://localhost:8000
- Swagger UI: http://localhost:8000/docs
- Flower (Celery monitoring): http://localhost:5555
</details>

## 🏃‍♂️ Quick Start

### 1. Run a Simple Strategy

```python
# simple_strategy.py
from app.services.market_data import MarketDataService
from app.strategies.moving_average import MovingAverageStrategy
import asyncio

async def run_simple_strategy():
    # Initialize services with fallback enabled
    market_data = MarketDataService(use_fallback=True)
    strategy = MovingAverageStrategy(short_window=10, long_window=30)
    
    # Get historical data (falls back to sample data if needed)
    data = await market_data.get_historical_data("AAPL", "2024-01-01", "2024-03-01")
    
    # Process data and generate signals
    processed_data = await strategy.preprocess_data(data)
    signal, confidence = await strategy.predict(processed_data)
    
    print(f"AAPL Trading Signal: {signal} (Confidence: {confidence:.2f})")

if __name__ == "__main__":
    asyncio.run(run_simple_strategy())
```

Run the script:
```bash
python simple_strategy.py
```

### 2. Launch the Interactive Dashboard

```bash
streamlit run strategy_dashboard.py
```

This will open a browser window with an interactive dashboard to explore strategy performance.

### 3. Run a Comprehensive Simulation

```bash
python comprehensive_simulation.py --timeframe daily
```

## 🔌 API Reference

<details>
<summary><strong>Available API Endpoints</strong></summary>

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/strategies` | GET | List all available trading strategies |
| `/api/strategies/{strategy_name}` | GET | Get details about a specific strategy |
| `/api/predictions/{strategy_name}/{symbol}` | POST | Get a prediction for a symbol |
| `/api/backtests` | POST | Run a backtest for a strategy |
| `/api/backtests/{backtest_id}` | GET | Get backtest results |
| `/api/models/train` | POST | Train a strategy model |
| `/api/models/{model_id}` | GET | Get model details |
| `/api/trades` | POST | Execute a trade |
| `/api/account` | GET | Get account information |
| `/api/market/status` | GET | Check market status |

For complete API documentation, run the server and visit `/docs` or check the [API Reference](./docs/api/README.md).
</details>

## 🔧 Extending Mercurio Systems

### Creating Custom Strategies

<details>
<summary><strong>Click to see how to add custom strategies</strong></summary>

Mercurio Systems follows a plugin architecture for strategies, making it easy to implement your own trading logic:

1. Create a new Python file in the `app/strategies` directory
2. Extend the `BaseStrategy` class
3. Implement required methods

```python
from app.strategies.base import BaseStrategy
import pandas as pd
import numpy as np

class MyCustomStrategy(BaseStrategy):
    """My custom mean-reversion trading strategy"""
    
    def __init__(self, lookback_period=20, threshold=2.0):
        self.lookback_period = lookback_period
        self.threshold = threshold
        self.name = "MeanReversionStrategy"
        self.description = "Buys oversold assets and sells overbought assets"
        
    async def preprocess_data(self, data):
        """Calculate z-scores for mean reversion"""
        df = data.copy()
        
        # Calculate rolling mean and standard deviation
        df['rolling_mean'] = df['close'].rolling(window=self.lookback_period).mean()
        df['rolling_std'] = df['close'].rolling(window=self.lookback_period).std()
        
        # Calculate z-score
        df['z_score'] = (df['close'] - df['rolling_mean']) / df['rolling_std']
        
        return df.dropna()
        
    async def predict(self, data):
        """Generate trading signals based on z-scores"""
        if data.empty or len(data) < self.lookback_period:
            return "HOLD", 0.0
            
        current_z = data.iloc[-1]['z_score']
        
        # Mean reversion logic
        if current_z < -self.threshold:
            # Oversold, potential buy
            signal = "BUY"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        elif current_z > self.threshold:
            # Overbought, potential sell
            signal = "SELL"
            confidence = min(abs(current_z) / 4, 1.0)  # Normalize confidence
        else:
            signal = "HOLD"
            confidence = 1.0 - (abs(current_z) / self.threshold)
            
        return signal, float(confidence)
```

Register your strategy in `app/strategies/__init__.py` to make it available throughout the system.
</details>

### Custom Data Sources

<details>
<summary><strong>Click to see how to add custom data sources</strong></summary>

Extend the `BaseDataProvider` class to integrate with any market data source:

```python
from app.services.data_providers.base import BaseDataProvider
import pandas as pd
import requests

class MyCustomDataProvider(BaseDataProvider):
    """Custom data provider for XYZ market data"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://api.example.com/v1"
        
    async def get_historical_data(self, symbol, start_date, end_date, timeframe="1d"):
        """Fetch historical market data from custom source"""
        # Implementation
        headers = {"Authorization": f"Bearer {self.api_key}"} if self.api_key else {}
        params = {
            "symbol": symbol,
            "from": start_date,
            "to": end_date,
            "interval": timeframe
        }
        
        response = requests.get(f"{self.base_url}/historical", headers=headers, params=params)
        data = response.json()
        
        # Transform to standard format
        df = pd.DataFrame(data["bars"])
        df.columns = ["timestamp", "open", "high", "low", "close", "volume"]
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df.set_index("timestamp", inplace=True)
        
        return df
```
</details>

## 🔬 Running the Comprehensive Simulation

Test all available strategies across different assets and timeframes:

```bash
python comprehensive_simulation.py --start-date 2024-03-03 --end-date 2025-04-25 --initial-capital 10000
```

This runs a full-year simulation using:
- **5 Stock Assets**: AAPL, MSFT, GOOGL, AMZN, TSLA
- **5 Crypto Assets**: BTC-USD, ETH-USD, SOL-USD, ADA-USD, DOT-USD
- **All Strategies**: MovingAverage, LSTM, Transformer, LLM, MSI
- **Multiple Timeframes**: Daily, Weekly, Monthly

Results are saved to the `reports/comprehensive/` directory with full metrics and visualizations.

## 📚 Documentation

Comprehensive documentation is available in the [docs](./docs) directory:

### 📔 Guides Principaux

- **[🔍 Index des Guides](./docs/GUIDES_INDEX.md)**: Point d'entrée central avec tous les guides disponibles
- **[📈 Guide de Day Trading](./docs/day_trading_guide.md)**: Système automatisé de day trading sur actions et crypto
- **[📊 Guide des Options](./docs/options_trading.md)**: Trading d'options avec Mercurio AI
- **[🧠 Guide d'Entraînement des Modèles](./docs/model_training_guide.md)**: Créer et entraîner des modèles d'IA

### 📖 Documentation Générale

- **[📚 Pour les Débutants](./docs/for-dummies/README.md)**: Guide complet en 12 chapitres pour débutants
- **[🔰 Guides Débutants](./docs/guides/beginner/)**: Ressources pour démarrer rapidement
- **[🔧 Guides Avancés](./docs/guides/advanced/)**: Sujets spécialisés pour traders expérimentés
- **[📝 Documentation Référence](./docs/reference/)**: Détails techniques et spécifications API

## 🧪 Testing

```bash
# Run the test suite
pytest

# Run tests with coverage
pytest --cov=app
```

## 🤝 Contributing

Contributions are welcome! Check out the [contribution guidelines](CONTRIBUTING.md) to get started.

## 📄 License

This project is open-source and available under the MIT License.

## 🌟 Showcase

<div align="center">
  <table>
    <tr>
      <td align="center"><img src="https://i.imgur.com/2sGSK1h.png" width="400"/><br><b>Strategy Comparison</b></td>
      <td align="center"><img src="https://i.imgur.com/7fVLnMF.png" width="400"/><br><b>Portfolio Allocation</b></td>
    </tr>
  </table>
</div>

## 🙏 Acknowledgements

- [FastAPI](https://fastapi.tiangolo.com/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [PyTorch](https://pytorch.org/)
- [Pandas](https://pandas.pydata.org/)
- [Streamlit](https://streamlit.io/)
- [Polygon.io](https://polygon.io/)
- [Yahoo Finance](https://finance.yahoo.com/)
- [Alpaca Markets](https://alpaca.markets/)
- [Backtrader](https://www.backtrader.com/)



================================================
FILE: alpaca_crypto_trader.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Crypto Day Trading Script
--------------------------------
Script autonome pour le daytrading de cryptomonnaies via Alpaca API,
optimisé pour l'abonnement de niveau 3 (AlgoTrader Plus).

Utilisation:
    python alpaca_crypto_trader.py --duration 1h --log-level INFO
"""

import os
import time
import signal
import logging
import argparse
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta

# API Alpaca
import alpaca_trade_api as tradeapi
import pandas as pd
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration du logger
# Configurer la journalisation pour enregistrer dans un fichier
log_file = f"crypto_trader_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("alpaca_crypto_trader")

# Variables globales pour la gestion des signaux
running = True
session_end_time = None

# Enums pour la durée de session
class SessionDuration(int, Enum):
    ONE_HOUR = 3600
    FOUR_HOURS = 14400
    EIGHT_HOURS = 28800
    NIGHT_RUN = 32400  # 9 heures (pour couvrir toute la nuit)
    CUSTOM = 0

class AlpacaCryptoTrader:
    """
    Système de daytrading crypto utilisant directement l'API Alpaca
    
    Caractéristiques:
    - Utilise l'API Alpaca pour trader des cryptos en mode paper
    - Stratégie simple de croisement de moyennes mobiles
    - Plusieurs durées de session (1h, 4h, 8h, nuit)
    - Paramètres de trading configurables
    - Journalisation complète et rapport de performance
    """
    
    def __init__(self, session_duration: SessionDuration = SessionDuration.ONE_HOUR):
        """Initialiser le système de trading crypto"""
        self.session_duration = session_duration
        
        # Déterminer le mode Alpaca (paper ou live)
        alpaca_mode = os.getenv("ALPACA_MODE", "paper").lower()
        
        # Configuration selon le mode
        if alpaca_mode == "live":
            self.api_key = os.getenv("ALPACA_LIVE_KEY")
            self.api_secret = os.getenv("ALPACA_LIVE_SECRET")
            self.base_url = os.getenv("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            logger.info("Configuré pour le trading LIVE (réel)")
        else:  # mode paper par défaut
            self.api_key = os.getenv("ALPACA_PAPER_KEY")
            self.api_secret = os.getenv("ALPACA_PAPER_SECRET")
            self.base_url = os.getenv("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            logger.info("Configuré pour le trading PAPER (simulation)")
            
        # URL des données de marché
        self.data_url = os.getenv("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        # Niveau d'abonnement Alpaca
        self.subscription_level = int(os.getenv("ALPACA_SUBSCRIPTION_LEVEL", "1"))
        logger.info(f"Utilisation du niveau d'abonnement Alpaca: {self.subscription_level}")
        
        # Client API Alpaca
        self.api = None
        
        # Paramètres de trading
        self.symbols = []  # Sera rempli avec les symboles crypto disponibles
        self.custom_symbols = []  # Liste personnalisée de symboles à utiliser
        self.use_custom_symbols = False  # Si True, utilise custom_symbols au lieu de la liste filtrée
        self.fast_ma_period = 5   # 5 minutes pour la moyenne mobile rapide
        self.slow_ma_period = 15  # 15 minutes pour la moyenne mobile lente
        self.position_size_pct = 0.02  # 2% du portefeuille par position
        self.stop_loss_pct = 0.03  # 3% de stop loss
        self.take_profit_pct = 0.06  # 6% de prise de profit
        
        # Suivi de l'état
        self.positions = {}
        self.portfolio_value = 0.0
        self.initial_portfolio_value = 0.0
        self.session_start_time = None
        self.session_end_time = None
        self.trade_history = []  # Pour enregistrer l'historique des transactions
        
        logger.info("AlpacaCryptoTrader initialisé")
        
    def initialize(self):
        """Initialiser les services et charger la configuration"""
        try:
            # Initialiser le client API Alpaca
            self.api = tradeapi.REST(
                key_id=self.api_key,
                secret_key=self.api_secret,
                base_url=self.base_url,
                api_version='v2'
            )
            
            # Vérifier que le client est correctement initialisé
            account = self.api.get_account()
            if account:
                self.portfolio_value = float(account.portfolio_value)
                self.initial_portfolio_value = self.portfolio_value
                logger.info(f"Compte Alpaca connecté: {account.id}")
                logger.info(f"Valeur initiale du portefeuille: ${self.portfolio_value:.2f}")
                logger.info(f"Mode trading: {account.status}")
                
                # Vérifier la disponibilité du trading crypto
                assets = self.api.list_assets(asset_class='crypto')
                
                if not self.use_custom_symbols:
                    # Filtrer pour ne garder que les paires USD pures (exclure explicitement USDT/USDC)
                    self.symbols = [asset.symbol for asset in assets if asset.tradable 
                                  and '/USD' in asset.symbol 
                                  and not '/USDT' in asset.symbol 
                                  and not '/USDC' in asset.symbol]
                    
                    if self.symbols:
                        logger.info(f"Trouvé {len(self.symbols)} symboles crypto disponibles (USD seulement)")
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole crypto disponible avec USD")
                else:
                    # Utiliser la liste personnalisée et vérifier que les symboles sont tradables
                    tradable_assets = [asset.symbol for asset in assets if asset.tradable]
                    self.symbols = [symbol for symbol in self.custom_symbols if symbol in tradable_assets]
                    logger.info(f"Utilisation d'une liste personnalisée de {len(self.symbols)} symboles crypto")
                    if self.symbols:
                        logger.info(f"Exemples: {', '.join(self.symbols[:5])}")
                    else:
                        logger.warning("Aucun symbole personnalisé n'est tradable")
                    
                # Vérifier le solde disponible en USD
                try:
                    account = self.api.get_account()
                    cash = float(account.cash)
                    logger.info(f"Solde USD disponible: ${cash:.2f}")
                except Exception as e:
                    logger.warning(f"Impossible de récupérer le solde USD: {e}")
                    pass
                
                return True
            else:
                logger.error("Impossible de récupérer les informations du compte")
                return False
                
        except Exception as e:
            logger.error(f"Erreur d'initialisation: {e}")
            return False
            
    def start(self, duration_seconds: Optional[int] = None):
        """Démarrer la session de trading crypto"""
        self.session_start_time = datetime.now()
        
        if duration_seconds is not None:
            self.session_end_time = self.session_start_time + timedelta(seconds=duration_seconds)
        else:
            self.session_end_time = self.session_start_time + timedelta(seconds=int(self.session_duration))
            
        logger.info(f"Démarrage de la session de trading crypto à {self.session_start_time}")
        logger.info(f"La session se terminera à {self.session_end_time}")
        
        # Initialiser le trader
        initialized = self.initialize()
        if not initialized:
            logger.error("Échec de l'initialisation, abandon")
            self.generate_performance_report()
            return
            
        # Démarrer la boucle de trading
        self.trading_loop()
        
        # Générer un rapport de performance à la fin
        self.generate_performance_report()
            
    def trading_loop(self):
        """Boucle principale de trading"""
        global running
        
        try:
            while running and datetime.now() < self.session_end_time:
                # Déterminer les symboles à trader pour cette itération
                # Limiter aux 10 premières cryptos pour éviter les limites de taux si pas de liste personnalisée
                trading_symbols = self.symbols[:10] if (len(self.symbols) > 10 and not self.use_custom_symbols) else self.symbols
                
                # Traiter chaque symbole
                for symbol in trading_symbols:
                    try:
                        self.process_symbol(symbol)
                    except Exception as e:
                        logger.error(f"Erreur de traitement de {symbol}: {e}")
                
                # Mettre à jour l'état du portefeuille
                self.update_portfolio_state()
                
                # Attendre 60 secondes avant la prochaine itération
                time_remaining = int((self.session_end_time - datetime.now()).total_seconds() / 60)
                logger.info(f"Attente de 60 secondes avant le prochain cycle. Fin de session dans {time_remaining} minutes")
                time.sleep(60)
                
        except Exception as e:
            logger.error(f"Erreur dans la boucle de trading: {e}")
        finally:
            logger.info("Boucle de trading terminée")
            
    def process_symbol(self, symbol: str):
        """Traiter un symbole de trading"""
        logger.info(f"Traitement de {symbol}")
        
        # Obtenir les données historiques (intervalles de 5 minutes pour les dernières 24 heures)
        end = datetime.now()
        start = end - timedelta(days=1)
        
        try:
            # Formater les dates pour l'API
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            # Obtenir les barres de prix (corriger l'erreur expected list, str found)
            bars = self.api.get_crypto_bars(
                [symbol],  # Passer une liste au lieu d'une chaîne
                timeframe='5Min',
                start=start_str,
                end=end_str
            ).df
            
            if bars.empty:
                logger.warning(f"Pas de données historiques disponibles pour {symbol}")
                return
            
            # Si les données sont multi-index (symbole, timestamp), prendre juste le symbole concerné
            if isinstance(bars.index, pd.MultiIndex):
                bars = bars.loc[symbol]
                
            # Calculer les moyennes mobiles
            bars['fast_ma'] = bars['close'].rolling(window=self.fast_ma_period).mean()
            bars['slow_ma'] = bars['close'].rolling(window=self.slow_ma_period).mean()
            
            # Obtenir la position actuelle
            position = None
            try:
                position = self.api.get_position(symbol)
            except:
                pass  # Pas de position existante
            
            # Obtenir le prix actuel (compatible avec abonnement niveau 1)
            try:
                # Pour le niveau 1, on peut utiliser la dernière barre des dernières 5 minutes comme prix actuel
                if not bars.empty:
                    current_price = float(bars.iloc[-1]['close'])
                    logger.info(f"{symbol} prix actuel (dernière barre): ${current_price:.4f}")
                else:
                    logger.error(f"Pas de données disponibles pour obtenir le prix actuel de {symbol}")
                    return
            except Exception as e:
                logger.error(f"Impossible d'obtenir le prix actuel pour {symbol}: {e}")
                return
            
            # Logique de trading - Croisement de moyennes mobiles
            if len(bars) >= self.slow_ma_period:
                last_row = bars.iloc[-1]
                prev_row = bars.iloc[-2]
                
                # Vérifier le signal d'achat: MA rapide croise au-dessus de la MA lente
                buy_signal = (
                    prev_row['fast_ma'] <= prev_row['slow_ma'] and 
                    last_row['fast_ma'] > last_row['slow_ma']
                )
                
                # Vérifier le signal de vente: MA rapide croise en dessous de la MA lente
                sell_signal = (
                    prev_row['fast_ma'] >= prev_row['slow_ma'] and 
                    last_row['fast_ma'] < last_row['slow_ma']
                )
                
                # Exécuter les signaux
                if buy_signal and not position:
                    self.execute_buy(symbol, current_price)
                elif sell_signal and position:
                    self.execute_sell(symbol, current_price, position)
                
                # Vérifier le stop loss et le take profit
                if position:
                    entry_price = float(position.avg_entry_price)
                    if entry_price > 0:
                        pnl_pct = (current_price - entry_price) / entry_price
                        
                        if pnl_pct <= -self.stop_loss_pct:
                            logger.info(f"{symbol} a atteint le stop loss à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
                        elif pnl_pct >= self.take_profit_pct:
                            logger.info(f"{symbol} a atteint le take profit à {pnl_pct:.2%}")
                            self.execute_sell(symbol, current_price, position)
            
        except Exception as e:
            logger.error(f"Erreur de traitement de {symbol}: {e}")
    
    def execute_buy(self, symbol: str, price: float):
        """Exécuter un ordre d'achat"""
        try:
            # Calculer la taille de la position
            position_value = self.portfolio_value * self.position_size_pct
            qty = position_value / price
            
            logger.info(f"SIGNAL D'ACHAT: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Arrondir la quantité à 6 décimales
            qty = round(qty, 6)
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre d'achat placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'achat',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre d'achat pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution d'achat pour {symbol}: {e}")
    
    def execute_sell(self, symbol: str, price: float, position):
        """Exécuter un ordre de vente"""
        try:
            qty = float(position.qty)
            
            if qty <= 0:
                logger.warning(f"Quantité de position invalide pour {symbol}: {qty}")
                return
                
            logger.info(f"SIGNAL DE VENTE: {symbol} à ${price:.4f}, qté: {qty:.6f}")
            
            # Placer un ordre au marché
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side='sell',
                type='market',
                time_in_force='gtc'
            )
            
            if order:
                logger.info(f"Ordre de vente placé pour {symbol}: {order.id}")
                self.trade_history.append({
                    'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'symbol': symbol,
                    'action': 'vente',
                    'quantity': qty,
                    'price': price
                })
            else:
                logger.error(f"Échec du placement de l'ordre de vente pour {symbol}")
                
        except Exception as e:
            logger.error(f"Erreur d'exécution de vente pour {symbol}: {e}")
    
    def update_portfolio_state(self):
        """Mettre à jour la valeur du portefeuille et les positions"""
        try:
            account = self.api.get_account()
            self.portfolio_value = float(account.portfolio_value)
            logger.info(f"Valeur actuelle du portefeuille: ${self.portfolio_value:.2f}")
            
            # Mettre à jour les positions
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                # Journaliser les positions ouvertes
                if crypto_positions:
                    logger.info(f"Positions ouvertes actuelles: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes")
            except Exception as e:
                logger.error(f"Erreur de récupération des positions: {e}")
                
        except Exception as e:
            logger.error(f"Erreur de mise à jour de l'état du portefeuille: {e}")
    
    def generate_performance_report(self):
        """Générer un rapport de performance à la fin de la session de trading"""
        # Créer un fichier de rapport séparé
        report_file = f"crypto_trading_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            end_time = datetime.now()
            duration = end_time - self.session_start_time if self.session_start_time else timedelta(0)
            hours, remainder = divmod(duration.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            logger.info("===================================================")
            logger.info("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO")
            logger.info("===================================================")
            logger.info(f"Durée de la session: {hours}h {minutes}m {seconds}s")
            logger.info(f"Heure de début: {self.session_start_time}")
            logger.info(f"Heure de fin: {end_time}")
            
            # Obtenir l'état final du compte
            try:
                account = self.api.get_account()
                final_value = float(account.portfolio_value)
                
                if self.initial_portfolio_value > 0:
                    profit_loss = final_value - self.initial_portfolio_value
                    profit_loss_pct = (profit_loss / self.initial_portfolio_value) * 100
                    logger.info(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}")
                    logger.info(f"Valeur finale du portefeuille: ${final_value:.2f}")
                    logger.info(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations finales du compte: {e}")
            
            # Afficher les positions ouvertes
            try:
                positions = self.api.list_positions()
                crypto_positions = [p for p in positions if '/' in p.symbol]
                
                if crypto_positions:
                    logger.info(f"Positions ouvertes à la fin de la session: {len(crypto_positions)}")
                    for pos in crypto_positions:
                        entry_price = float(pos.avg_entry_price)
                        current_price = float(pos.current_price)
                        qty = float(pos.qty)
                        market_value = float(pos.market_value)
                        pnl = float(pos.unrealized_pl)
                        pnl_pct = float(pos.unrealized_plpc) * 100
                        
                        logger.info(f"  {pos.symbol}: {qty:.6f} @ ${entry_price:.4f} - Valeur: ${market_value:.2f} - P/L: ${pnl:.2f} ({pnl_pct:.2f}%)")
                else:
                    logger.info("Pas de positions ouvertes à la fin de la session")
            except Exception as e:
                logger.warning(f"Impossible de récupérer les informations de position: {e}")
                
            logger.info("===================================================")
            logger.info("SESSION DE TRADING CRYPTO TERMINÉE")
            logger.info("===================================================")
                
        except Exception as e:
            logger.error(f"Erreur de génération du rapport de performance: {e}")

        # Écrire le rapport également dans un fichier séparé
        with open(report_file, 'w') as f:
            f.write("===================================================\n")
            f.write("RAPPORT DE PERFORMANCE DE LA SESSION DE TRADING CRYPTO\n")
            f.write("===================================================\n\n")
            f.write(f"Durée de la session: {hours}h {minutes}m {seconds}s\n")
            f.write(f"Heure de début: {self.session_start_time}\n")
            f.write(f"Heure de fin: {end_time}\n\n")
            
            try:
                if self.initial_portfolio_value > 0:
                    f.write(f"Valeur initiale du portefeuille: ${self.initial_portfolio_value:.2f}\n")
                    f.write(f"Valeur finale du portefeuille: ${final_value:.2f}\n")
                    f.write(f"Profit/Perte: ${profit_loss:.2f} ({profit_loss_pct:.2f}%)\n\n")
            except:
                f.write("Impossible de récupérer les informations finales du compte\n\n")
                
            f.write("Positions ouvertes à la fin de la session:\n")
            try:
                if crypto_positions:
                    for pos in crypto_positions:
                        f.write(f"  {pos.symbol}: {float(pos.qty):.6f} @ ${float(pos.avg_entry_price):.4f} - ")
                        f.write(f"Valeur: ${float(pos.market_value):.2f} - ")
                        f.write(f"P/L: ${float(pos.unrealized_pl):.2f} ({float(pos.unrealized_plpc) * 100:.2f}%)\n")
                else:
                    f.write("Aucune position ouverte\n")
            except:
                f.write("Impossible de récupérer les informations de position\n")
            
            f.write("\n===================================================\n")
            f.write("RÉSUMÉ DES TRANSACTIONS IMPORTANTES\n")
            f.write("===================================================\n")
            if hasattr(self, 'trade_history') and self.trade_history:
                for trade in self.trade_history:
                    f.write(f"{trade['time']} - {trade['symbol']} - {trade['action']} - ")
                    f.write(f"{trade['quantity']:.6f} @ ${trade['price']:.4f} - P/L: ${trade.get('pnl', 0):.2f}\n")
            else:
                f.write("Aucune transaction effectuée\n")
                
        logger.info(f"Rapport détaillé sauvegardé dans {report_file}")

def main():
    """Point d'entrée principal"""
    parser = argparse.ArgumentParser(description="Système de trading crypto Alpaca")
    parser.add_argument("--duration", type=str, choices=["1h", "4h", "8h", "custom"], default="1h",
                        help="Durée de la session de trading (1h, 4h, 8h, ou custom)")
    parser.add_argument("--custom-seconds", type=int, default=0,
                        help="Durée personnalisée en secondes si --duration=custom")
    parser.add_argument("--log-level", type=str, choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="Niveau de journalisation")
                        
    args = parser.parse_args()
    
    # Définir le niveau de journalisation
    numeric_level = getattr(logging, args.log_level)
    logging.basicConfig(level=numeric_level, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    
    # Déterminer la durée de la session
    duration_map = {
        "1h": SessionDuration.ONE_HOUR,
        "4h": SessionDuration.FOUR_HOURS,
        "8h": SessionDuration.EIGHT_HOURS,
        "custom": SessionDuration.CUSTOM
    }
    session_duration = duration_map.get(args.duration, SessionDuration.ONE_HOUR)
    custom_duration = args.custom_seconds if args.duration == "custom" else 0
    
    # Créer le trader
    trader = AlpacaCryptoTrader(session_duration=session_duration)
    
    # Enregistrer les gestionnaires de signaux pour une fermeture propre
    def signal_handler(sig, frame):
        global running, session_end_time
        logger.info(f"Signal {sig} reçu, arrêt en cours...")
        running = False
        session_end_time = datetime.now()
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Exécuter le trader
    try:
        if custom_duration > 0:
            trader.start(custom_duration)
        else:
            trader.start()
    except KeyboardInterrupt:
        logger.info("Interruption clavier reçue, arrêt en cours...")
    except Exception as e:
        logger.error(f"Erreur d'exécution du trader crypto: {e}")
    finally:
        logger.info("Arrêt du trader crypto terminé")

if __name__ == "__main__":
    main()



================================================
FILE: alpaca_premium_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca Premium Subscription Test

Vérifie spécifiquement les fonctionnalités premium de votre abonnement Alpaca à 100$/mois.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging to be plus lisible
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api importé avec succès")
except ImportError:
    logger.error("❌ Erreur d'importation de alpaca-trade-api. Installation...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("✅ alpaca-trade-api installé et importé avec succès")

def test_premium_features():
    """Teste les fonctionnalités spécifiques aux abonnements premium d'Alpaca"""
    
    # Charger les variables d'environnement
    load_dotenv()
    
    # Tester à la fois le mode PAPER et LIVE si possible
    results = {}
    
    for mode in ["paper", "live"]:
        logger.info(f"\n{'='*60}")
        logger.info(f"TEST DU MODE {mode.upper()}")
        logger.info(f"{'='*60}\n")
        
        # Récupérer les informations d'authentification appropriées
        if mode == "paper":
            api_key = os.environ.get("ALPACA_PAPER_KEY")
            api_secret = os.environ.get("ALPACA_PAPER_SECRET")
            base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        else:
            api_key = os.environ.get("ALPACA_LIVE_KEY")
            api_secret = os.environ.get("ALPACA_LIVE_SECRET")
            base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
            data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
        
        results[mode] = {
            "connection": False,
            "account_info": False,
            "market_data": {
                "daily": False,
                "minute": False,
                "realtime": False,
                "extended_history": False,
                "multiple_symbols": False,
            },
            "news_data": False,
            "fundamental_data": False,
            "subscription_tier": "Unknown"
        }
        
        try:
            # Initialiser l'API Alpaca
            api = REST(
                key_id=api_key,
                secret_key=api_secret,
                base_url=base_url,
                data_url=data_url
            )
            results[mode]["connection"] = True
            logger.info(f"✅ Connecté à l'API Alpaca en mode {mode.upper()}")
            
            # 1. Test des informations de compte
            try:
                account = api.get_account()
                results[mode]["account_info"] = True
                logger.info(f"✅ Informations du compte: ID={account.id}, Status={account.status}")
                logger.info(f"   Valeur portefeuille: ${float(account.portfolio_value):.2f}")
                
                # Essayer de déterminer le niveau d'abonnement
                try:
                    if hasattr(account, 'subscription_status'):
                        results[mode]["subscription_tier"] = account.subscription_status
                        logger.info(f"✅ Niveau d'abonnement: {account.subscription_status}")
                    else:
                        logger.info("ℹ️ Impossible de déterminer le niveau d'abonnement directement")
                except:
                    pass
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des informations du compte: {e}")
            
            # 2. Test des données de marché historiques (journalières)
            logger.info("\n----- TEST DES DONNÉES DE MARCHÉ -----")
            symbol = "AAPL"
            end_date = datetime.now()
            
            # 2.1 Test données journalières sur 5 jours (devrait fonctionner même sans abonnement premium)
            try:
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données journalières pour {symbol} du {start_str} au {end_str}...")
                daily_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(daily_bars) > 0:
                    results[mode]["market_data"]["daily"] = True
                    logger.info(f"✅ {len(daily_bars)} barres journalières récupérées")
                    logger.info(f"   Dernier prix de clôture: ${daily_bars[-1].c:.2f}")
                else:
                    logger.warning(f"⚠️ Aucune donnée journalière récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données journalières: {e}")
            
            # 2.2 Test données minutes (souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=1)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération des données minutes pour {symbol} des dernières 24h...")
                minute_bars = api.get_bars(symbol, "1Min", start_str, end_str)
                
                if len(minute_bars) > 0:
                    results[mode]["market_data"]["minute"] = True
                    logger.info(f"✅ {len(minute_bars)} barres minutes récupérées")
                    logger.info(f"   Première barre: {minute_bars[0].t}")
                    logger.info(f"   Dernière barre: {minute_bars[-1].t}")
                else:
                    logger.warning(f"⚠️ Aucune donnée minute récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données minutes: {e}")
            
            # 2.3 Test historique étendu (2+ ans, souvent limité aux abonnements premium)
            try:
                start_date = end_date - timedelta(days=365*2 + 30)  # ~2 ans et 1 mois
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                logger.info(f"Récupération de l'historique étendu pour {symbol} (2+ ans)...")
                long_bars = api.get_bars(symbol, "1Day", start_str, end_str)
                
                if len(long_bars) > 0:
                    days_of_data = (datetime.fromisoformat(long_bars[-1].t) - 
                                  datetime.fromisoformat(long_bars[0].t)).days
                    
                    if days_of_data > 365*2:
                        results[mode]["market_data"]["extended_history"] = True
                        logger.info(f"✅ {len(long_bars)} barres d'historique étendu récupérées")
                        logger.info(f"   Couvrant {days_of_data} jours de données")
                    else:
                        logger.warning(f"⚠️ Historique limité à {days_of_data} jours (< 2 ans)")
                else:
                    logger.warning(f"⚠️ Aucune donnée d'historique étendu récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération de l'historique étendu: {e}")
            
            # 2.4 Test données pour plusieurs symboles simultanément
            try:
                symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
                logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
                
                start_date = end_date - timedelta(days=5)
                start_str = start_date.date().isoformat()
                end_str = end_date.date().isoformat()
                
                multi_bars = api.get_bars(symbols, "1Day", start_str, end_str)
                
                if multi_bars and len(multi_bars) > 0:
                    results[mode]["market_data"]["multiple_symbols"] = True
                    logger.info(f"✅ Données récupérées pour plusieurs symboles:")
                    for symbol, bars in multi_bars.items():
                        logger.info(f"   {symbol}: {len(bars)} barres")
                else:
                    logger.warning("⚠️ Aucune donnée récupérée pour les multiples symboles")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des données multi-symboles: {e}")
            
            # 3. Test des données de news (souvent limité aux abonnements premium)
            logger.info("\n----- TEST DES DONNÉES DE NEWS -----")
            try:
                logger.info(f"Récupération des news pour {symbol}...")
                news = api.get_news(symbol)
                
                if news and len(news) > 0:
                    results[mode]["news_data"] = True
                    logger.info(f"✅ {len(news)} articles de news récupérés")
                    logger.info(f"   Dernier titre: {news[0].headline}")
                    logger.info(f"   Source: {news[0].source}")
                else:
                    logger.warning(f"⚠️ Aucune news récupérée pour {symbol}")
            except Exception as e:
                logger.error(f"❌ Erreur lors de la récupération des news: {e}")
            
            # Résumé des tests
            logger.info("\n----- RÉSUMÉ DES TESTS -----")
            
            if results[mode]["connection"]:
                logger.info(f"✅ Connexion au mode {mode.upper()}: Réussie")
            else:
                logger.error(f"❌ Connexion au mode {mode.upper()}: Échec")
                
            if results[mode]["account_info"]:
                logger.info(f"✅ Informations du compte: Disponibles")
            else:
                logger.error(f"❌ Informations du compte: Non disponibles")
            
            logger.info(f"Données de marché:")
            for data_type, success in results[mode]["market_data"].items():
                status = "✅ Disponible" if success else "❌ Non disponible"
                logger.info(f"  - {data_type}: {status}")
            
            news_status = "✅ Disponible" if results[mode]["news_data"] else "❌ Non disponible"
            logger.info(f"Données de news: {news_status}")
            
            # Analyse de l'abonnement
            premium_features = sum([
                results[mode]["market_data"]["minute"],
                results[mode]["market_data"]["extended_history"],
                results[mode]["market_data"]["multiple_symbols"],
                results[mode]["news_data"]
            ])
            
            if premium_features >= 3:
                logger.info("🌟 Votre compte semble avoir un abonnement premium!")
            elif premium_features >= 1:
                logger.info("⭐ Votre compte semble avoir certaines fonctionnalités premium.")
            else:
                logger.warning("⚠️ Votre compte ne semble pas avoir d'abonnement premium.")
            
        except Exception as e:
            logger.error(f"❌ Erreur générale lors du test du mode {mode}: {e}")
    
    return results

if __name__ == "__main__":
    logger.info("\n🚀 DÉMARRAGE DU TEST D'ABONNEMENT PREMIUM ALPACA")
    logger.info("Ce test va vérifier si votre abonnement Alpaca à 100$/mois fonctionne correctement")
    
    results = test_premium_features()
    
    logger.info("\n\n🏁 TEST TERMINÉ")
    logger.info("Récapitulatif des fonctionnalités premium détectées:")
    
    for mode in results:
        premium_count = sum([
            results[mode]["market_data"]["minute"],
            results[mode]["market_data"]["extended_history"],
            results[mode]["market_data"]["multiple_symbols"],
            results[mode]["news_data"]
        ])
        
        if premium_count >= 3:
            status = "🌟 PREMIUM"
        elif premium_count >= 1:
            status = "⭐ PARTIEL"
        else:
            status = "❌ STANDARD"
            
        logger.info(f"Mode {mode.upper()}: {status} ({premium_count}/4 fonctionnalités premium)")
    
    logger.info("\nSi vous ne voyez pas toutes les fonctionnalités premium, vérifiez que:")
    logger.info("1. Votre abonnement est bien activé sur le compte Alpaca")
    logger.info("2. Les clés API utilisées correspondent au compte avec l'abonnement")
    logger.info("3. L'abonnement inclut bien les fonctionnalités testées")



================================================
FILE: alpaca_test.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Alpaca API Access Test Script

This script tests access to Alpaca API to verify your credentials
and subscription are working correctly.
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully imported alpaca-trade-api")
except ImportError:
    logger.error("Failed to import alpaca-trade-api. Trying to install it...")
    
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
    logger.info("Successfully installed and imported alpaca-trade-api")

def test_alpaca_access():
    """Test access to Alpaca API with current credentials"""
    
    # Load environment variables from .env file
    load_dotenv()
    
    # Check if we're using paper or live mode
    alpaca_mode = os.environ.get("ALPACA_MODE", "paper").lower()
    
    if alpaca_mode == "paper":
        api_key = os.environ.get("ALPACA_PAPER_KEY")
        api_secret = os.environ.get("ALPACA_PAPER_SECRET")
        base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
        logger.info("Testing Alpaca PAPER trading mode")
    else:
        api_key = os.environ.get("ALPACA_LIVE_KEY")
        api_secret = os.environ.get("ALPACA_LIVE_SECRET")
        base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
        logger.info("Testing Alpaca LIVE trading mode")
    
    if not api_key or not api_secret:
        logger.error(f"Alpaca API credentials for {alpaca_mode.upper()} mode not found in .env file")
        logger.info("Please check your .env file configuration")
        return False
    
    logger.info(f"Testing Alpaca API with key: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialize Alpaca API
    try:
        # Connect to Alpaca API with specified credentials
        api = REST(
            key_id=api_key,
            secret_key=api_secret,
            base_url=base_url
        )
        logger.info(f"Successfully connected to Alpaca {alpaca_mode.upper()} Trading API")
        
        # Get account information
        account = api.get_account()
        logger.info(f"Account ID: {account.id}")
        logger.info(f"Account Status: {account.status}")
        logger.info(f"Portfolio Value: ${float(account.portfolio_value):.2f}")
        logger.info(f"Cash Balance: ${float(account.cash):.2f}")
        logger.info(f"Buying Power: ${float(account.buying_power):.2f}")
        
        # Check market data access
        try:
            # Test market data access with a well-known symbol
            symbol = 'AAPL'
            end = datetime.now()
            start = end - timedelta(days=5)
            
            # Format dates as ISO format strings
            start_str = start.date().isoformat()
            end_str = end.date().isoformat()
            
            # Get daily bar data
            logger.info(f"Attempting to get historical data for {symbol} from {start_str} to {end_str}")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if len(bars) > 0:
                logger.info(f"Successfully retrieved {len(bars)} bars of data")
                logger.info(f"Latest close price for {symbol}: ${bars[-1].c:.2f}")
                logger.info("Market data access is working correctly!")
            else:
                logger.warning(f"No data returned for {symbol}. This could be due to market holidays or data limitations.")
        
        except Exception as e:
            logger.error(f"Error accessing market data: {e}")
            logger.warning("Your Alpaca subscription might not include market data access")
            
        # Check subscription details
        try:
            # This will only work if the account has access to this endpoint
            account_configurations = api.get_account_configurations()
            logger.info("Successfully retrieved account configurations")
            logger.info(f"Account Configurations: {json.dumps(account_configurations.__dict__, indent=2)}")
        except Exception as e:
            logger.warning(f"Could not retrieve account configurations: {e}")
        
        # Check for active subscriptions
        logger.info("Your Alpaca account is active and working correctly!")
        return True
        
    except Exception as e:
        logger.error(f"Error connecting to Alpaca API: {e}")
        logger.error("Please check your API credentials and subscription status")
        return False

def test_data_subscription(api, alpaca_mode):
    """Test specific data subscription features"""
    logger.info("\n=== Testing Alpaca Data Subscription ===\n")
    
    try:
        # Testing real-time data by requesting market data
        # This is a specific feature of paid subscriptions
        symbol = 'AAPL'
        end = datetime.now()
        start = end - timedelta(days=60)  # Try for longer period to test subscription
        
        # Format dates as ISO format strings
        start_str = start.date().isoformat()
        end_str = end.date().isoformat()
        
        # Get minute data as this might be restricted to paid plans
        logger.info(f"Attempting to get 1-minute resolution data for {symbol} (last 7 days)")
        week_start = end - timedelta(days=7)
        week_start_str = week_start.date().isoformat()
        
        minute_bars = api.get_bars(symbol, '1Min', week_start_str, end_str)
        if len(minute_bars) > 0:
            logger.info(f"✅ Successfully retrieved {len(minute_bars)} minute bars")
            logger.info(f"First bar: {minute_bars[0].__dict__}")
            logger.info(f"Last bar: {minute_bars[-1].__dict__}")
        else:
            logger.warning("❌ No minute data retrieved, this might indicate a subscription limitation")
        
        # Test for fundamental data (if available in the subscription)
        try:
            logger.info("\nAttempting to access fundamental data...")
            
            # Try to access news API (often restricted to paid subscriptions)
            news = api.get_news(symbol)
            if news and len(news) > 0:
                logger.info(f"✅ Successfully retrieved {len(news)} news items for {symbol}")
                logger.info(f"Latest news: {news[0].headline}")
            else:
                logger.warning("❌ No news data retrieved, this might indicate a subscription limitation")
        except Exception as e:
            logger.warning(f"❌ Could not access fundamental data: {e}")
            logger.warning("This might be restricted in your current subscription plan")
        
        # Test data for multiple symbols (batch request)
        try:
            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
            logger.info(f"\nTesting batch data for {len(symbols)} symbols...")
            
            batch_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            if batch_bars and sum(len(bars) for symbol, bars in batch_bars.items()) > 0:
                logger.info(f"✅ Successfully retrieved batch data for multiple symbols")
                for symbol, bars in batch_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} bars")
            else:
                logger.warning("❌ Batch data retrieval failed or returned no data")
        except Exception as e:
            logger.warning(f"❌ Batch data retrieval error: {e}")
            logger.warning("This might be restricted in your current subscription plan")
            
        return True
    except Exception as e:
        logger.error(f"Error testing data subscription: {e}")
        return False

if __name__ == "__main__":
    # Add command line arguments to choose between paper and live mode
    import argparse
    parser = argparse.ArgumentParser(description='Test Alpaca API access and subscription features')
    parser.add_argument('--mode', choices=['paper', 'live', 'both'], default='paper',
                       help='Trading mode to test: paper, live, or both (default: paper)')
    parser.add_argument('--data', action='store_true', help='Run additional tests for data subscription features')
    
    args = parser.parse_args()
    
    # Modify .env variable temporarily if testing both or specific mode
    if args.mode == 'both':
        modes = ['paper', 'live']
    else:
        modes = [args.mode]
    
    all_successful = True
    
    for mode in modes:
        logger.info(f"\n=== Alpaca API Access Test: {mode.upper()} MODE ===\n")
        
        # Override mode in environment
        os.environ['ALPACA_MODE'] = mode
        
        if test_alpaca_access():
            logger.info(f"✅ Basic connectivity test for {mode.upper()} mode completed successfully!")
            
            # Test data subscription features if requested
            if args.data:
                # Get the current mode's API credentials
                load_dotenv()
                if mode == "paper":
                    api_key = os.environ.get("ALPACA_PAPER_KEY")
                    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
                    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
                else:
                    api_key = os.environ.get("ALPACA_LIVE_KEY")
                    api_secret = os.environ.get("ALPACA_LIVE_SECRET")
                    base_url = os.environ.get("ALPACA_LIVE_URL", "https://api.alpaca.markets")
                
                api = REST(key_id=api_key, secret_key=api_secret, base_url=base_url)
                test_data_subscription(api, mode)
        else:
            logger.error(f"❌ Tests failed for {mode.upper()} mode. Please check the error messages above.")
            all_successful = False
    
    if all_successful:
        logger.info("\n=== SUMMARY ===\n")
        logger.info("✅ All Alpaca API tests completed successfully!")
        logger.info("Your Alpaca subscription is working correctly.")
    else:
        logger.error("\n=== SUMMARY ===\n")
        logger.error("❌ Some Alpaca API tests failed. Please check the error messages above.")
        logger.error("Your subscription might have limitations or configuration issues.")
        
    logger.info("\nTo test data subscription features more thoroughly, run:")
    logger.info("python alpaca_test.py --mode both --data")
    
    if 'live' in modes:
        logger.warning("\nNOTE: Tests included LIVE mode which connects to your real trading account.")
        logger.warning("      No trades were executed, but please verify the connection was successful.")




================================================
FILE: check_alpaca_plus.py
================================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vérification de l'abonnement AlgoTrader Plus d'Alpaca
Ce script teste les fonctionnalités spécifiques à l'abonnement premium.
"""

import os
import sys
import logging
import json
from datetime import datetime, timedelta
from pprint import pprint
from dotenv import load_dotenv

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST
except ImportError:
    logger.error("Installation de alpaca-trade-api...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "alpaca-trade-api"])
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.rest import REST

def main():
    """Fonction principale pour vérifier l'abonnement AlgoTrader Plus"""
    
    # Utiliser les variables du fichier .env
    api_key = os.environ.get("ALPACA_PAPER_KEY")
    api_secret = os.environ.get("ALPACA_PAPER_SECRET")
    base_url = os.environ.get("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets")
    data_url = os.environ.get("ALPACA_DATA_URL", "https://data.alpaca.markets")
    
    if not api_key or not api_secret:
        logger.error("Clés API Alpaca non définies dans le fichier .env")
        return
        
    logger.info(f"Connexion à Alpaca avec la clé: {api_key[:4]}...{api_key[-4:]}")
    
    # Initialisation de l'API
    api = REST(
        key_id=api_key,
        secret_key=api_secret,
        base_url=base_url
    )
    
    try:
        # 1. Vérifier les informations du compte et l'abonnement
        account = api.get_account()
        logger.info(f"ID du compte: {account.id}")
        logger.info(f"Statut du compte: {account.status}")
        
        try:
            # Tentative de récupérer les détails de l'abonnement (peut ne pas fonctionner)
            account_config = api.get_account_configurations()
            logger.info("Configuration du compte:")
            logger.info(json.dumps(account_config.__dict__, indent=2))
        except Exception as e:
            logger.warning(f"Impossible de récupérer la configuration du compte: {e}")
        
        # 2. Vérifier l'accès aux données de marché
        # Symboles à tester
        symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA"]
        symbol = symbols[0]
        
        logger.info("\n==== TEST DES DONNÉES EN TEMPS RÉEL ====")
        
        # 2.1 Vérifier les données en temps réel
        try:
            logger.info(f"Récupération du dernier prix pour {symbol}...")
            last_trade = api.get_latest_trade(symbol)
            logger.info(f"Dernier prix de {symbol}: ${last_trade.price:.2f}")
            logger.info(f"Horodatage: {last_trade.timestamp}")
            
            # Vérifier si l'horodatage est récent (moins de 15 min de retard)
            trade_time = datetime.fromisoformat(last_trade.timestamp.replace('Z', '+00:00'))
            delay = datetime.now() - trade_time.replace(tzinfo=None)
            logger.info(f"Délai des données: {delay.total_seconds() / 60:.2f} minutes")
            
            if delay.total_seconds() < 900:  # 15 minutes
                logger.info("✅ DONNÉES EN TEMPS RÉEL CONFIRMÉES")
            else:
                logger.warning("⚠️ Les données semblent être retardées")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des derniers prix: {e}")
        
        logger.info("\n==== TEST DES DONNÉES HISTORIQUES PREMIUM ====")
        
        # 2.2 Vérifier l'accès aux données historiques étendues
        try:
            # Test sur 2 ans
            end = datetime.now()
            start = end - timedelta(days=365*2)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données historiques pour {symbol} du {start_str} au {end_str}...")
            bars = api.get_bars(symbol, '1Day', start_str, end_str)
            
            if bars and len(bars) > 0:
                logger.info(f"✅ {len(bars)} jours de données historiques récupérées")
                logger.info(f"Premier jour: {bars[0].t}")
                logger.info(f"Dernier jour: {bars[-1].t}")
                
                # Analyse de la période couverte
                first_date = datetime.fromisoformat(bars[0].t.replace('Z', '+00:00'))
                last_date = datetime.fromisoformat(bars[-1].t.replace('Z', '+00:00'))
                days_covered = (last_date - first_date).days
                
                logger.info(f"Période couverte: {days_covered} jours")
                
                if days_covered > 700:  # ~2 ans
                    logger.info("✅ HISTORIQUE ÉTENDU PREMIUM CONFIRMÉ")
                else:
                    logger.warning("⚠️ Historique limité, peut-être pas d'accès premium complet")
            else:
                logger.warning("Aucune donnée historique récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données historiques: {e}")
        
        # 2.3 Vérifier l'accès aux données à haute résolution
        logger.info("\n==== TEST DES DONNÉES À HAUTE RÉSOLUTION ====")
        try:
            # Test des données minutes
            end = datetime.now()
            start = end - timedelta(days=1)  # 1 jour
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données minutes pour {symbol}...")
            minute_bars = api.get_bars(symbol, '1Min', start_str, end_str)
            
            if minute_bars and len(minute_bars) > 0:
                logger.info(f"✅ {len(minute_bars)} barres de données minutes récupérées")
                logger.info("✅ DONNÉES À HAUTE RÉSOLUTION CONFIRMÉES")
            else:
                logger.warning("Aucune donnée minute récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données minutes: {e}")
        
        # 2.4 Vérifier l'accès aux données de plusieurs symboles
        logger.info("\n==== TEST DES DONNÉES MULTI-SYMBOLES ====")
        try:
            end = datetime.now()
            start = end - timedelta(days=5)
            
            start_str = start.strftime('%Y-%m-%d')
            end_str = end.strftime('%Y-%m-%d')
            
            logger.info(f"Récupération des données pour plusieurs symboles: {symbols}...")
            multi_bars = api.get_bars(symbols, '1Day', start_str, end_str)
            
            if multi_bars:
                symbol_count = len(multi_bars)
                logger.info(f"✅ Données récupérées pour {symbol_count} symboles:")
                for symbol, bars in multi_bars.items():
                    logger.info(f"  - {symbol}: {len(bars)} barres")
                
                if symbol_count >= 3:
                    logger.info("✅ DONNÉES MULTI-SYMBOLES CONFIRMÉES")
            else:
                logger.warning("Aucune donnée multi-symboles récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données multi-symboles: {e}")
        
        # 3. Vérifier l'accès aux données fondamentales
        logger.info("\n==== TEST DES DONNÉES FONDAMENTALES ====")
        try:
            logger.info(f"Récupération des données fondamentales pour {symbol}...")
            # Les news sont souvent incluses dans les abonnements premium
            news = api.get_news(symbol)
            
            if news and len(news) > 0:
                logger.info(f"✅ {len(news)} articles de news récupérés")
                logger.info(f"Dernier titre: {news[0].headline}")
                logger.info("✅ DONNÉES DE NEWS CONFIRMÉES")
            else:
                logger.warning("Aucune donnée de news récupérée")
        except Exception as e:
            logger.error(f"Erreur lors de la récupération des données fondamentales: {e}")
        
        # 4. Résumé des résultats
        logger.info("\n==== RÉSUMÉ DES TESTS ALGOTRADER PLUS ====")
        logger.info("Votre abonnement Alpaca AlgoTrader Plus a été testé pour les fonctionnalités suivantes:")
        logger.info("1. Compte et configuration")
        logger.info("2. Données en temps réel")
        logger.info("3. Historique étendu (2+ ans)")
        logger.info("4. Données à haute résolution (minutes)")
        logger.info("5. Données multi-symboles")
        logger.info("6. Données fondamentales/news")
        
        logger.info("\nCes fonctionnalités sont toutes disponibles dans votre abonnement AlgoTrader Plus.")
        logger.info("Mercurio AI est maintenant configuré pour utiliser ces fonctionnalités premium.")
    
    except Exception as e:
        logger.error(f"Erreur lors des tests Alpaca: {e}")

if __name__ == "__main__":
    logger.info("=== VÉRIFICATION DE L'ABONNEMENT ALPACA ALGOTRADER PLUS ===")
    main()
    logger.info("=== FIN DES TESTS ===")


